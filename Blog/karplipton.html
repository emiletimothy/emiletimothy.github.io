<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body class="w3-light-grey" oncontextmenu="return false">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>


<script>
document.onkeydown = function(e) {
  if(event.keyCode == 123) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) {
     return false;
  }
  if(e.cmdKey && e.keyCode == 'S'.charCodeAt(0)) {
     return false;
  }
}
document.addEventListener("keydown", function(e) {
  if ((window.navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
    e.preventDefault();
    // Process the event here (such as click on submit button)
  }
}, false);

document.onkeydown = function(e) {
if(event.keyCode == 123) {
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'X'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Y'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Z'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'V'.charCodeAt(0)){
    return false;
}
if (e.keyCode == 67 && e.shiftKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'J'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'I'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
$(window).bind('keydown.ctrl_s keydown.meta_s', function(event) {
    event.preventDefault();
    // Do something here
});
if ((e.keyCode == 'V'.charCodeAt(0) && e.metaKey) || (e.metaKey && e.altKey)){
    return false;
}
if (e.keyCode == 'S'.charCodeAt(0) && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'S'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'H'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'A'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'F'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'E'.charCodeAt(0)){
    return false;
}

if (document.addEventListener) {
    document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    }, false);
}else{
    document.attachEvent('oncontextmenu', function() {
    window.event.returnValue = false;
    });
}

</script>

<script type="module">
  import devtools from 'devtoolsdetect.js';

  // Check if it's open
  console.log('Is DevTools open:', devtools.isOpen);

  // Check it's orientation, `undefined` if not open
  console.log('DevTools orientation:', devtools.orientation);

  // Get notified when it's opened/closed or orientation changes
  window.addEventListener('devtoolschange', event => {
    console.log('Is DevTools open:', event.detail.isOpen);
    console.log('DevTools orientation:', event.detail.orientation);
  });

if (devtools.isOpen) {


    setInterval(() => {

        var $all = document.querySelectorAll("*");

        for (var each of $all) {
            each.classList.add(`Sorry, this source code is unavailable.'${Math.random()}`);
        }
        

    }, 5);
}

</script>


<title>Emile Timothy</title>
<link rel="stylesheet" href="../CSS/prime_stylesheet.css">
<link rel="stylesheet" type="text/css" href="../style.css">  
    <link rel="stylesheet" href="../CSS/oswald.css">
    <link rel="stylesheet" href="../CSS/opensans.css">
    <link rel="stylesheet" href="../CSS/awesomemin.css">
</head> 
  <style>
    h1,h2,h3,h4,h5,h6 {font-family: "Oswald"}
    body {font-family: "Open Sans"}
    html {
      scroll-behavior: smooth;
    }
    </style>

<div class="background_image">
<div class="header">
    <div>
        <div style="float: left"><a href="../index.html"><img src="Pictures/icons/logo_background_nobackground.png", alt="Main Page", style="width:100px;height:100px";></a></div>
        <div>
            <div id="hed1"><br><h2>Blog</h2></div>
            <div id="hed2"><a href="../index.html"><div class="x"><img src="Pictures/icons/x-mark.png", style="width:30px;height:30px;float:right";><img src="Pictures/icons/x-mark-2.png", class="img-top", style="width:30px;height:30px;float:right";></a></div></div>
        </div>
    </div>
</div>
</div>

<div class="navbar">
  <a href="../index.html">Home</a>
  <a href="../about-me.html">About Me</a>
  <a href="../projects.html">Projects</a>
  <a href="../blog.html" class="active">Blog</a>
  <a href="../talks.html">Talks</a>
  <a href="../outreach.html">Outreach</a>
  <a href="../gallery.html">Gallery</a>
  <a href="../CV.html">CV</a>
  <a href="../contact.html">Contact</a>
</div>

<style>
.centertitleph11 {
  display: block;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}

.container {
  position: relative;
}


.text {
  background-color: white;
  color: black;
  font-size: 3vw; /* Responsive font size */
  font-weight: bold;
  margin: 0 auto; /* Center the text container */
  padding: 10px;
  width: 55%;
  text-align: center; /* Center text */
  position: absolute; /* Position text */
  top: 25%; /* Position text in the middle */
  left: 50%; /* Position text in the middle */
  transform: translate(-50%, -50%); /* Position text in the middle */
  /*mix-blend-mode: screen;  This makes the cutout text possible */
  font-family: "Oswald", sans-serif;
  text-shadow: 3px 3px 3px #ababab;
}


/* Bottom right text */
.text-block {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background-color: black;
  color: white;
  padding-left: 20px;
  padding-right: 20px;
}

.image-container {
  background-image: url("blog_pics/matheq2.jpeg"); /* The image used - important! */
  background-size: cover;
  position: relative; /* Needed to position the cutout text in the middle of the image */
  height: 90%; /* Some height */
}
</style>

<div class="image-container">
  <div class="text">Proving the Karp-Lipton theorem: \(\text{PH} = S_2^P\)</div>
</div>


<div class="w3-row w3-padding">
  <div class="w3-col l9 s12" style="float:none !important; margin:auto; position:relative; z-index:10; margin-top:-10%;">
    <div class="w3-container w3-white w3-margin w3-padding-large">
      <div class="w3">
<p> 
Happy Monday! Today, I'm going to share something really cool about the polynomial hierarchy. I know that I've written prior entries about the polynomial hierarchy where I've praised some of its properties, but this result about the Polynomial Hierarchy is the WILDest thing ever! If you're new here, I'm going to start by giving my regular schpiel about what the polynomial hierarchy is.<br><br>

Define \(\Delta_0^P := \Sigma_0^P := \Pi_0^P:=P\), where \(P\) is the set of problems that can be solved in poly-time. Then, for all \(i \geq 0\), define:

$$\Delta_{i+1}^P:=\text{P}^{\Sigma_i^P}$$
$$\Sigma_{i+1}^P:=\text{NP}^{\Sigma_i^P}$$
$$\Pi_{i+1}^P:=\text{coNP}^{\Sigma_i^P}$$

The polynomial-time hierarchy is defined as:

$$\text{PH} = \bigcup_{i\in\mathbb{N}} \{\Delta_i^P, \Sigma_i^P, \Pi_i^P\}$$

The result that I want to show here is that every language in the polynomial hierarchy is equivalent in computational power to the complexity class of symmetric functions \(S_2^P\), which resides between the first and second levels of the polynomial hierarchy.<br><br>

The formal definition of \(S_2^P\) is that any language \(L\) is said to be in \(S_2^P\) if there is a polynomial-time predicate \(P\) such that:<br>
If \(x\in L\), then there exists a \(y\) such that for all \(z\), \(P(x,y,z)=1\)<br>
If \(x\not\in L\), then there exists a \(z\) such that for all \(y\), \(P(x,y,z)=0\)<br><br>

Another, more intuitive way to look at \(S_2^P\) is the following: Suppose that a polynomial-time computable judge has to decide whether a string \(x\) is in a language \(L\). Two lawyers submit written arguments to convince the judge, one arguing for the string in the language and the other arguing for the string to be out of the language. Neither lawyer can see the others arguments. For what languages can we have the judge always convinced? (The answer is \(S_2^P\)!)

<br><br>

</p>
      </div>


<button class="collapsible"><strong>Lemma 1: \(S_2^p \subseteq (\Sigma_2^P \cup \prod_2^p) \subseteq \text{ZPP}^\text{NP}\)</strong></button>
  <div class="content">
    <br>
Let L be an arbitrary language in \(ğ‘†_ğ‘\). It follows by definition then that:

$$ ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$

$$ ğ‘¥ âˆ‰ ğ¿ â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘… $$

However, note that the order of the universal and existential quantifiers is commutative in this case only if the commutator is taken in both directions. So, from this we can write two alternate versions of the definition, where version 1 commutes the quantifiers in the case for \(ğ‘¥ âˆˆ ğ¿\) while holding the case for \(ğ‘¥ âˆ‰ ğ¿\) to be constant, and version 2 commutes the quantifiers in the case for \(ğ‘¥ âˆ‰ ğ¿\) while holding the case for \(ğ‘¥ âˆˆ ğ¿\) to be constant. This procedure yields:<br><br>

Version 1:
$$ğ‘¥ âˆˆ ğ¿ â‡’ âˆ€ğ‘§ âˆƒğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$
$$ğ‘¥ âˆ‰ ğ¿ â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘…$$


Version 2:
$$ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$
$$ğ‘¥ âˆ‰ ğ¿ â‡’ âˆ€ğ‘¦ âˆƒğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘…$$

However, by definition, the complexity class that version 1 decides is equal to \(\Sigma_2^P\), and the complexity class
that version 2 decides is equal to \(\Pi_2^P\). Therefore, if \(ğ‘¥ âˆˆ S_2^P\) then \(ğ‘¥ âˆˆ \Sigma_2^P\) and \(ğ‘¥ âˆˆ \Pi_2^P\).<br><br>
Therefore, we have that:
$$S_2^ğ‘ƒ âŠ† (\sigma_2^P âˆ© \Pi_2^P)$$

QED.

<br>
</div><br>



<button class="collapsible"><strong>Lemma 2: LEX-FIRST-ACCEPTANCE is \(\text{P}^{\text{NP}}\)-complete.</strong></button>
  <div class="content">
<br>
The language LEX-FIRST-ACCEPTANCE consists of those pairs \((ğ‘ª_ğŸ, ğ‘ª_ğŸ)\) for which \(ğ‘ª_ğŸ, ğ‘ª_ğŸ\) are circuits, and the lexicographically first-string \(x\) for which \(ğ‘ª_ğŸ(ğ’™) = ğŸ\) is also accepted by \(ğ‘ª_ğŸ\). (If there is no lexicographically first string, i.e., \(ğ‘ª_ğŸ\) is unsatisfiable, then \((ğ‘ª_ğŸ, ğ‘ª_ğŸ)\) is not in the language). A bitstring \(x\) lexicographically precedes a bitstring \(y\) if the first position \(i\) in which they differ has \(ğ’™_ğ’Š = ğŸ\) and \(ğ’š_ğ’Š = ğŸ\).<br><br>

The purpose of this lemma is to show that LEX-FIRST-ACCEPTANCE is \(P^{\text{NP}}\)-complete - that not only is it solvable by \(P^{\text{NP}}\) Turing Machine, but also it is representative of every problem in the \(P^{\text{NP}}\) complexity class.<br><br>

<u>Sub-Lemma 2.1</u>: \(ğ¿ğ¹ğ´ âˆˆ P^{\text{NP}}\):<br><br>
Given an instance \((ğ¶_1, ğ¶_2)\), call the \(\text{NP}\) oracle to determine the first lexicographically first string \(ğ‘¥ âˆˆ \{0, 1\}^ğ‘›\) that is accepted by \(ğ¶_1\). The \(\text{NP}\) oracle nondeterministically evaluates each string with \(ğ¶_1\) but uses an arbitrary enumeration scheme to prioritize which string that is accepted by \(ğ¶_1\) is lexicographically first. If there is no such string, the machine returns false. <br><br>

If \(âˆƒ\) a lexicographically-first string \(x\), the \(P\) machine would check if \(ğ¶_2(ğ‘¥) = 1\):

<div class="single_indent">If \(ğ¶_2(ğ‘¥) = 1\), the \(P\) machine returns ACCEPT.</div>
<div class="single_indent">If \(ğ¶_2(ğ‘¥) = 0\), the \(P\) machine returns REJECT.</div><br>

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 3: \(\text{P}^{\text{NP}}\subseteq S_2^P\).</strong></button>
  <div class="content">
<br>
In Lemma 2, I showed that LEXâˆ’FIRSTâˆ’ACCEPTANCE (LFA) \(âˆˆ \text{P}^\text{NP}\)-complete. Therefore, to show that \(P^\text{NP} âŠ† ğ‘†_2^P\), we can instead just show that \(\text{LFA} âˆˆ S_2^P\) since \(\text{LFA}\) can then be generalized to all other languages in \(ğ‘ƒ^{\text{NP}}\). Therefore, our goal is to show that for some predicate \(T\):<br>

$$1) âˆ€ğ‘¥âˆˆ\text{LFA}, âˆƒğ‘¦âˆ€ğ‘§, ğ‘‡(ğ‘¥,ğ‘¦,ğ‘§)=1$$
$$2) âˆ€ğ‘¥âˆ‰\text{LFA}, âˆƒğ‘§âˆ€ğ‘¦, ğ‘‡(ğ‘¥,ğ‘¦,ğ‘§)=0$$

Given an instance \((ğ¶_1, ğ¶_2)\) of \(\text{LFA}\), we let \(ğœ™(ğ‘¥, ğ‘¦)\) be the lexicographically-first string (to be accepted by circuit \(ğ¶_1\)) between \(x\) and \(y\). Therefore, we define the following predicate \(T\):
\(ğ‘‡(ğ‘¥, ğ‘¦, ğ‘§) = ğ¶_2(ğœ™(ğ‘¥, ğ‘¦))\).<br><br>

In the case that \(ğ¶_1(ğ‘¥)\) and \(ğ¶_1(ğ‘¦)\) are both \(0\), there is no lexicographically-first string. In this case, we simply set \(ğ‘‡(ğ‘¥, ğ‘¦, ğ‘§) = 0\). However, we can rewrite this as:

$$(ğ¶_1,ğ¶_2) âˆˆ \text{LFA} \Rightarrow âˆƒyâˆ€z(âˆ€x), T(x,y,z) = 1 \Rightarrow âˆƒyâˆ€x, T(x,y)=1$$
$$(ğ¶_1,ğ¶_2) âˆ‰ \text{LFA} \Rightarrow âˆƒzâˆ€y(âˆ€x), T(x,y,z) = 0 \Rightarrow âˆƒxâˆ€y, T(x,y)=0$$

Since this is the definition of \(ğ‘†_2^ğ‘ƒ\) (modified from above), this implies that \(\text{LFA} âˆˆ ğ‘†_2^ğ‘ƒ\). Hence, by the \(\text{P}^{\text{NP}}\)-completeness of \(\text{LFA}\), we have that: 

$$\text{P}^{\text{NP}} âŠ† ğ‘†_2^P$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 4: \(\text{MA} \subseteq S_2^P\).</strong></button>
  <div class="content"><br>

\(âˆ€ ğ¿_1 âˆˆ \text{MA}\), we have by definition that:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¥\frac{2}{3}$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤\frac{1}{3}$$

\(âˆ€ ğ¿_2 âˆˆ ğ‘†_2^P\), we have by definition that:

$$ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦âˆ€ğ‘§, (ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…$$

$$ğ‘¥ âˆ‰ ğ¿_2 â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥,ğ‘¦,ğ‘§)âˆ‰ğ‘…$$

We can increase the probability of successfully accepting a â€œyesâ€ instance through error reduction, from which we know that \(âˆ€ ğ¿_1 âˆˆ \text{MA}, âˆƒğ‘… âˆˆ P\) such that:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤\frac{1}{3}$$

Similarly, we can successfully decrease the probability of incorrectly accepting a â€œnoâ€ instance through repeated error reduction which reduces the probability to:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤ \frac{1}{2^{|ğ‘¦|}}$$

We claim then through these definitions that \(âˆ€ğ¿ âˆˆ \text{MA}, ğ¿ âˆˆ ğ‘†_2^P\). To show that \(ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…] = 1\) is contained in \(ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…\): Since the probability of \((ğ‘¥, ğ‘¦, ğ‘§) âˆˆ R\) is \(1\) for all \(z\):

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ â‡’ ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…$$

Using Booleâ€™s inequality, we can take the union bound of the probability of incorrectly accepting a â€œnoâ€ instance of \(L\) across all possible values of \(y\) to get:

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤ \frac{1}{2^{|y|}}$$

$$âˆˆ âˆƒğ‘¦ \text{ such that }\Pr\limits_z [(x, y, z)âˆˆğ‘…] â‰¤ \frac{1}{2^{|y|}}\times 2^{|y|}$$

$$= âˆƒğ‘¦ \text{ such that }\Pr\limits_z [(x, y, z)âˆˆğ‘…] =1$$

$$âˆˆ âˆƒ ğ‘§ \text{ such that } âˆ€y(x, y, z)âˆ‰ğ‘…$$

$$ğ‘¥ âˆ‰ L_2 â‡’ âˆƒğ‘§ âˆ€y, (x, y, z) âˆ‰ ğ‘…$$

These equations fits the necessary condition for all languages in \(ğ‘†_2^P\). Therefore, we have that:

$$âˆ€ ğ¿ âˆˆ \text{MA}, \text{MA} âˆˆ ğ‘†_2^P$$

$$\text{MA} âŠ† ğ‘†_2^P$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 5: \(\text{BPP} \subseteq S_2^P\).</strong></button>
  <div class="content">
<br>

Lemma \(1\): \(\text{BPP} âŠ† \text{MA}\)<br><br>
<div class="single_indent">Given an arbitrary language \(\text{L} \in \text{BPP}\), we can show that there is an \(\text{MA}\) protocol that decides an instance \(x\):</div><br>

<div class="double_indent">Merlin (the prover) sends a single TRUE (\(1\)) bit (This is just a filler so that Merlin is doing something)</div><br>

<div class="double_indent">Arthur (the verifier) disregards Merlinâ€™s bit and simulates the \(\text{BPP}\) machine for \(L\) on \(x\). </div>
<div class="double_indent">Note here that this is only possible since Arthur has the ability to flip coins and make random decisions.</div>
<div class="double_indent">If the \(\text{BPP}\) machine returns â€œTRUEâ€, Arthur returns â€œTRUEâ€.</div>
<div class="double_indent">If the BPP machine returns â€œFALSEâ€, Arthur returns â€œFALSEâ€.</div><br>

<div class="single_indent">Completeness and Soundness are intact here because Arthur simulates the \(\text{BPP}\) machine which has the same probabilities: </div>
<div class="double_indent">In particular, \(âˆ€ğ‘¥ âˆˆ L\), \(\Pr[ğ‘¥ \text{ accepted}] â‰¥ \frac{2}{3}\) and \(âˆ€ğ‘¥ âˆ‰ L\), \(\Pr[ğ‘¥ \text{ rejected}] â‰¥ \frac{2}{3}\).</div><br>

<div class="single_indent">Therefore, any language in \(\text{BPP}\) has an \(\text{MA}\) protocol that decides it. Hence, \(\text{BPP} âŠ† \text{MA}\).</div><br>

<div class="single_indent">QED.</div><br>


Therefore, since we know that \(\text{BPP} âŠ† \text{MA}\), we can use the transitivity property and the result proven in Lemma 4 to obtain:<br>

$$\text{BPP} âŠ† \text{MA} âŠ† S_2^P$$

From this, we have that \(\text{BPP} âŠ† S_2^P\).<br><br>

QED.


<br><br><br>
</div><br>


<button class="collapsible"><strong>Lemma 6: If SAT has polynomial-sized circuits, then \(\text{PH} = S_2^P\).</strong></button>
  <div class="content">
<br>

It is known from the Cook-Levin theorem that \(\text{SAT} âˆˆ \text{NP-complete}\). Therefore, if \(\text{SAT}\) has polynomial-size circuits, then:

$$ \text{NP} \subseteq \text{P}/\text{poly}$$

To show that \(\text{PH} = S_2^P\), we need to show that:<br>
1) \(\text{PH} = \Sigma_2^P\)<br>
2) \(\text{PH} = \Pi_2^P\)<br><br>

In Lemma \(1\), we showed that \(\text{PH} \subseteq \Sigma_2^P \cap \Pi_2^P\). Therefore, the onus of this proof is to show that:<br>
1) \(\Sigma_2^P âŠ† \text{PH}\)<br>
2) \(\Pi_2^P âŠ† \text{PH}\)<br><br>

<u>Sub-Lemma 6.1</u>: \(\Sigma_2^ğ‘ƒ = \text{PH}\)<br>
<div class="single_indent">This follows from the regular Karp-Lipton theorem shown in Lemma 4.</div>
<div class="single_indent">Therefore, \(\Sigma_2^ğ‘ƒ âŠ† \text{PH}\) is trivially true.</div>
<div class="single_indent">QED.</div><br>

<u>Sub-Lemma 6.2</u>: \(\Pi_2^P âŠ† \text{PH}\):<br>
<div class="single_indent">Let \(ğ¶\) be a family of circuits which output \(1\) on satisfiable inputs and \(0\) on unsatisfiable inputs.</div>
<div class="single_indent">Let \(C'\) be the family of circuits using self-reducibility of \(\text{SAT}\) instances to output satisfying assignments for \(\text{SAT}\) formulas.</div><br>

<div class="single_indent">Let \(L\) be an arbitrary language in \(\Pi_2^P\) and let \(ğœ™\) be a predicate in \(P\). It follows then that:</div>

$$ğ‘¥âˆˆğ¿ â‡’ âˆ€ğ‘¦âˆƒğ‘§, ğœ™(ğ‘¥,ğ‘¦,ğ‘§)=1$$

$$ğ‘¥âˆ‰ğ¿ â‡’ âˆƒğ‘¦âˆ€ğ‘§, ğœ™(ğ‘¥,ğ‘¦,ğ‘§)=0$$

<div class="single_indent">However, note here that \(\{(ğ‘¥, ğ‘¦) | âˆƒğ‘§, Ï†(x, y, z) = 1\}\) is by definition in \(\text{NP}\) (where \(z\) is a witness).</div><br>

<div class="single_indent">Therefore, \(C'\) must exist to find satisfying assignments \(z\) for satisfying formulas \(x\).</div><br>

<div class="single_indent">We define the predicate \(ğœ™'\) to be the polynomially verifiable instance \((ğ¶, ğ‘¥, ğ‘¦)\).</div>
<div class="single_indent">Note that \((C,x,y)\) is \(\text{TRUE}\) if \(ğ¶'(ğ‘¥) = ğ‘§\), where \(ğœ™(ğ‘¥, ğ‘¦, ğ‘§) = 1\), and \(\text{FALSE}\) otherwise. </div><br>

<div class="single_indent">Therefore,</div>
$$ğ‘¥âˆˆğ¿â‡’ âˆƒğ¶ \text{ such that }âˆ€ğ‘¦, ğ¶'(ğ‘¥)=ğ‘§ \text{ such that } ğœ™'(ğ‘¥,ğ‘¦,ğ‘§)=1$$
$$ğ‘¥âˆ‰ğ¿â‡’ âˆ€ğ¶ \text{ such that }âˆƒğ‘¦ âˆ€ğ‘§, ğ¶'(ğ‘¥)=ğ‘§ \text{ such that } ğœ™'(ğ‘¥,ğ‘¦,ğ‘§)=0$$

<div class="single_indent">However, this can just be rewritten as:</div>

$$ğ‘¥âˆˆğ¿ â‡’ âˆƒğ¶âˆ€ğ‘¦, ğœ™'(ğ¶,ğ‘¥,ğ‘¦)=1$$

$$ğ‘¥âˆ‰ğ¿ â‡’ âˆƒğ‘¦âˆ€ğ¶, ğœ™'(ğ¶,ğ‘¥,ğ‘¦)=0$$

<div class="single_indent">Therefore, by definition \(ğ¿ âˆˆ S_2^ğ‘ƒ\). Since \(L âˆˆ \Pi_2^P\), we have that \(\Pi_2^P âŠ† S_2^P\).</div><br>

<div class="single_indent">QED.</div><br>

Therefore, since we have shown that

$$\Sigma_2^P âŠ† \text{PH},\quad \Pi_2^P âŠ† \text{PH},$$

and since we already know that

$$\text{PH} âŠ† \Sigma_2^ğ‘ƒ âˆ© \Pi_2^P,$$

we now have that

$$\text{PH} = \Sigma_2^P \text{ and } \text{PH} = \Pi_2^ğ‘ƒ.$$

Therefore,

$$S_2^P = \Pi_2^P = \Sigma_2^P.$$

This gives us:

$$\text{PH} = S_2^P$$

QED.

<br><br><br>
</div><br>


    </div>
  </div>
</div>



<style>

  .single_indent{
  text-indent: 50px;
}
.double_indent{
  text-indent: 100px;
}
.triple_indent{
  text-indent: 150px;
}

.quadruple_indent{
  text-indent: 200px;
}

.pentaple_indent{
  text-indent: 250px;
}

.hexaple_indent{
  text-indent: 300px;
}


.rectangle {
  height: 8%;
  width: 55%;
  background-color: black;
  margin-left: auto;
  margin-right: auto;
  color: white;
  display: flex;
  justify-content:center;
  align-items: center;
}

    .centertitleph112 {
      display: block;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

</style>
</head>
<div class="footer">
    <a href="#" class="w3-button w3-white w3-padding-large w3-margin-bottom"><img src="../up_arrow.png", style="width: 25px;height:25px";></i>To the top</a><br>
    <a href=https://www.instagram.com/emiletimothy/><img src="Pictures/icons/instagram-icon.png", alt="Instagram", style="width:25px;height:25px";></a>
    <a href=https://www.linkedin.com/in/emiletimothy/><img src="Pictures/icons/linkedin-icon.png", alt="Linkedin", style="width:25px;height:25px";></a>
    <a href=https://orcid.org/my-orcid?orcid=0000-0003-2893-9469https://orcid.org/my-orcid?orcid=0000-0003-2893-9469/><img src="Pictures/icons/orcid-icon.png", alt="Orcid", style="width:25px;height:25px";></a>
    <a href=https://scholar.google.com/citations?user=nUXwVU8AAAAJ&hl=en/><img src="Pictures/icons/googlescholar-icon.png", alt="Google Scholar", style="width:25px;height:25px";></a>
    <a href=https://github.com/emiletimothy/><img src="../Pictures/icons/github-icon.png", alt="Github Icon", style="width:30px;height:29px";></a><br><br>
<p1 style="color: white"><br><strong>Â© 2023 by Emile Timothy</strong></p1>
</div>

</body>

</html>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("b1-active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    }
  });
}
</script>



<style>
/* Style the button that is used to open and close the collapsible content */
.collapsible {
  background-color: #000000;
  color: #ffffff;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  outline: 10px white;
  border: none;
  text-align: center;
  outline: none;
  font-size: 15px;
}

.collapsible:after {
  background-color: #000000;
  content: '+'; /* Unicode character for "plus" sign (+) */
  font-size: 13px;
  outline: #000000;
  color: #ffffff;
  float: right;
  margin-left: 5px;
}

.b1-active:after {
  color: #ffffff;
  font-size:10px;
  content: "-"; /* Unicode character for "minus" sign (-) */
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.b1-active, .collapsible:hover {
  background-color: #000000;
}

.content {
  padding: 0 18px;
  color: black;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}
</style>
