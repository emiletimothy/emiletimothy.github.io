<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body class="w3-light-grey" oncontextmenu="return false">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>


<script>
document.onkeydown = function(e) {
  if(event.keyCode == 123) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) {
     return false;
  }
  if(e.cmdKey && e.keyCode == 'S'.charCodeAt(0)) {
     return false;
  }
}
document.addEventListener("keydown", function(e) {
  if ((window.navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
    e.preventDefault();
    // Process the event here (such as click on submit button)
  }
}, false);

document.onkeydown = function(e) {
if(event.keyCode == 123) {
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'X'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Y'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Z'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'V'.charCodeAt(0)){
    return false;
}
if (e.keyCode == 67 && e.shiftKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'J'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'I'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
$(window).bind('keydown.ctrl_s keydown.meta_s', function(event) {
    event.preventDefault();
    // Do something here
});
if ((e.keyCode == 'V'.charCodeAt(0) && e.metaKey) || (e.metaKey && e.altKey)){
    return false;
}
if (e.keyCode == 'S'.charCodeAt(0) && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'S'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'H'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'A'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'F'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'E'.charCodeAt(0)){
    return false;
}

if (document.addEventListener) {
    document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    }, false);
}else{
    document.attachEvent('oncontextmenu', function() {
    window.event.returnValue = false;
    });
}

</script>

<script type="module">
  import devtools from 'devtoolsdetect.js';

  // Check if it's open
  console.log('Is DevTools open:', devtools.isOpen);

  // Check it's orientation, `undefined` if not open
  console.log('DevTools orientation:', devtools.orientation);

  // Get notified when it's opened/closed or orientation changes
  window.addEventListener('devtoolschange', event => {
    console.log('Is DevTools open:', event.detail.isOpen);
    console.log('DevTools orientation:', event.detail.orientation);
  });

if (devtools.isOpen) {


    setInterval(() => {

        var $all = document.querySelectorAll("*");

        for (var each of $all) {
            each.classList.add(`Sorry, this source code is unavailable.'${Math.random()}`);
        }
        

    }, 5);
}

</script>


<title>Emile Timothy</title>
<link rel="stylesheet" href="../CSS/prime_stylesheet.css">
<link rel="stylesheet" type="text/css" href="../style.css">  
    <link rel="stylesheet" href="../CSS/oswald.css">
    <link rel="stylesheet" href="../CSS/opensans.css">
    <link rel="stylesheet" href="../CSS/awesomemin.css">
</head> 
  <style>
    h1,h2,h3,h4,h5,h6 {font-family: "Oswald"}
    body {font-family: "Open Sans"}
    html {
      scroll-behavior: smooth;
    }
    </style>

<div class="background_image">
<div class="header">
    <div>
        <div style="float: left"><a href="../index.html"><img src="Pictures/icons/logo_background_nobackground.png", alt="Main Page", style="width:100px;height:100px";></a></div>
        <div>
            <div id="hed1"><br><h2>Blog</h2></div>
            <div id="hed2"><a href="../index.html"><div class="x"><img src="Pictures/icons/x-mark.png", style="width:30px;height:30px;float:right";><img src="Pictures/icons/x-mark-2.png", class="img-top", style="width:30px;height:30px;float:right";></a></div></div>
        </div>
    </div>
</div>
</div>

<div class="navbar">
  <a href="../index.html">Home</a>
  <a href="../about-me.html">About Me</a>
  <a href="../projects.html">Projects</a>
  <a href="../blog.html" class="active">Blog</a>
  <a href="../talks.html">Talks</a>
  <a href="../outreach.html">Outreach</a>
  <a href="../gallery.html">Gallery</a>
  <a href="../CV.html">CV</a>
  <a href="../contact.html">Contact</a>
</div>

<style>
.centertitleph11 {
  display: block;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}

.container {
  position: relative;
}


.text {
  background-color: white;
  color: black;
  font-size: 3vw; /* Responsive font size */
  font-weight: bold;
  margin: 0 auto; /* Center the text container */
  padding: 10px;
  width: 55%;
  text-align: center; /* Center text */
  position: absolute; /* Position text */
  top: 25%; /* Position text in the middle */
  left: 50%; /* Position text in the middle */
  transform: translate(-50%, -50%); /* Position text in the middle */
  /*mix-blend-mode: screen;  This makes the cutout text possible */
  font-family: "Oswald", sans-serif;
  text-shadow: 3px 3px 3px #ababab;
}


/* Bottom right text */
.text-block {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background-color: black;
  color: white;
  padding-left: 20px;
  padding-right: 20px;
}

.image-container {
  background-image: url("blog_pics/matheq2.jpeg"); /* The image used - important! */
  background-size: cover;
  position: relative; /* Needed to position the cutout text in the middle of the image */
  height: 90%; /* Some height */
}
</style>

<div class="image-container">
  <div class="text">Proving the Karp-Lipton theorem: \(\text{PH} = S_2^P\)</div>
</div>


<div class="w3-row w3-padding">
  <div class="w3-col l9 s12" style="float:none !important; margin:auto; position:relative; z-index:10; margin-top:-10%;">
    <div class="w3-container w3-white w3-margin w3-padding-large">
      <div class="w3">
<p> 
Happy Monday! Today, I'm going to share something really cool about the polynomial hierarchy. I know that I've written prior entries about the polynomial hierarchy where I've praised some of its properties, but this result about the Polynomial Hierarchy is the WILDest thing ever! If you're new here, I'm going to start by giving my regular schpiel about what the polynomial hierarchy is.<br><br>

Define \(\Delta_0^P := \Sigma_0^P := \Pi_0^P:=P\), where \(P\) is the set of problems that can be solved in poly-time. Then, for all \(i \geq 0\), define:

$$\Delta_{i+1}^P:=\text{P}^{\Sigma_i^P}$$
$$\Sigma_{i+1}^P:=\text{NP}^{\Sigma_i^P}$$
$$\Pi_{i+1}^P:=\text{coNP}^{\Sigma_i^P}$$

The polynomial-time hierarchy is defined as:

$$\text{PH} = \bigcup_{i\in\mathbb{N}} \{\Delta_i^P, \Sigma_i^P, \Pi_i^P\}$$

The result that I want to show here is that every language in the polynomial hierarchy is equivalent in computational power to the complexity class of symmetric functions \(S_2^P\), which resides between the first and second levels of the polynomial hierarchy.<br><br>

The formal definition of \(S_2^P\) is that any language \(L\) is said to be in \(S_2^P\) if there is a polynomial-time predicate \(P\) such that:<br>
If \(x\in L\), then there exists a \(y\) such that for all \(z\), \(P(x,y,z)=1\)<br>
If \(x\not\in L\), then there exists a \(z\) such that for all \(y\), \(P(x,y,z)=0\)<br><br>

Another, more intuitive way to look at \(S_2^P\) is the following: Suppose that a polynomial-time computable judge has to decide whether a string \(x\) is in a language \(L\). Two lawyers submit written arguments to convince the judge, one arguing for the string in the language and the other arguing for the string to be out of the language. Neither lawyer can see the others arguments. For what languages can we have the judge always convinced? (The answer is \(S_2^P\)!)

<br><br>

</p>
      </div>


<button class="collapsible"><strong>Lemma 1: \(S_2^p \subseteq (\Sigma_2^P \cup \prod_2^p) \subseteq \text{ZPP}^\text{NP}\)</strong></button>
  <div class="content">
    <br>
Let L be an arbitrary language in \(𝑆_𝑝\). It follows by definition then that:

$$ 𝑥 ∈ 𝐿 ⇒ ∃𝑦 ∀𝑧, (𝑥, 𝑦, 𝑧) ∈ 𝑅$$

$$ 𝑥 ∉ 𝐿 ⇒ ∃𝑧 ∀𝑦, (𝑥, 𝑦, 𝑧) ∉ 𝑅 $$

However, note that the order of the universal and existential quantifiers is commutative in this case only if the commutator is taken in both directions. So, from this we can write two alternate versions of the definition, where version 1 commutes the quantifiers in the case for \(𝑥 ∈ 𝐿\) while holding the case for \(𝑥 ∉ 𝐿\) to be constant, and version 2 commutes the quantifiers in the case for \(𝑥 ∉ 𝐿\) while holding the case for \(𝑥 ∈ 𝐿\) to be constant. This procedure yields:<br><br>

Version 1:
$$𝑥 ∈ 𝐿 ⇒ ∀𝑧 ∃𝑦, (𝑥, 𝑦, 𝑧) ∈ 𝑅$$
$$𝑥 ∉ 𝐿 ⇒ ∃𝑧 ∀𝑦, (𝑥, 𝑦, 𝑧) ∉ 𝑅$$


Version 2:
$$𝑥 ∈ 𝐿 ⇒ ∃𝑦 ∀𝑧, (𝑥, 𝑦, 𝑧) ∈ 𝑅$$
$$𝑥 ∉ 𝐿 ⇒ ∀𝑦 ∃𝑧, (𝑥, 𝑦, 𝑧) ∉ 𝑅$$

However, by definition, the complexity class that version 1 decides is equal to \(\Sigma_2^P\), and the complexity class
that version 2 decides is equal to \(\Pi_2^P\). Therefore, if \(𝑥 ∈ S_2^P\) then \(𝑥 ∈ \Sigma_2^P\) and \(𝑥 ∈ \Pi_2^P\).<br><br>
Therefore, we have that:
$$S_2^𝑃 ⊆ (\sigma_2^P ∩ \Pi_2^P)$$

QED.

<br>
</div><br>



<button class="collapsible"><strong>Lemma 2: LEX-FIRST-ACCEPTANCE is \(\text{P}^{\text{NP}}\)-complete.</strong></button>
  <div class="content">
<br>
The language LEX-FIRST-ACCEPTANCE consists of those pairs \((𝑪_𝟏, 𝑪_𝟐)\) for which \(𝑪_𝟏, 𝑪_𝟐\) are circuits, and the lexicographically first-string \(x\) for which \(𝑪_𝟏(𝒙) = 𝟏\) is also accepted by \(𝑪_𝟐\). (If there is no lexicographically first string, i.e., \(𝑪_𝟏\) is unsatisfiable, then \((𝑪_𝟏, 𝑪_𝟐)\) is not in the language). A bitstring \(x\) lexicographically precedes a bitstring \(y\) if the first position \(i\) in which they differ has \(𝒙_𝒊 = 𝟎\) and \(𝒚_𝒊 = 𝟏\).<br><br>

The purpose of this lemma is to show that LEX-FIRST-ACCEPTANCE is \(P^{\text{NP}}\)-complete - that not only is it solvable by \(P^{\text{NP}}\) Turing Machine, but also it is representative of every problem in the \(P^{\text{NP}}\) complexity class.<br><br>

<u>Sub-Lemma 2.1</u>: \(𝐿𝐹𝐴 ∈ P^{\text{NP}}\):<br><br>
Given an instance \((𝐶_1, 𝐶_2)\), call the \(\text{NP}\) oracle to determine the first lexicographically first string \(𝑥 ∈ \{0, 1\}^𝑛\) that is accepted by \(𝐶_1\). The \(\text{NP}\) oracle nondeterministically evaluates each string with \(𝐶_1\) but uses an arbitrary enumeration scheme to prioritize which string that is accepted by \(𝐶_1\) is lexicographically first. If there is no such string, the machine returns false. <br><br>

If \(∃\) a lexicographically-first string \(x\), the \(P\) machine would check if \(𝐶_2(𝑥) = 1\):

<div class="single_indent">If \(𝐶_2(𝑥) = 1\), the \(P\) machine returns ACCEPT.</div>
<div class="single_indent">If \(𝐶_2(𝑥) = 0\), the \(P\) machine returns REJECT.</div><br>

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 3: \(\text{P}^{\text{NP}}\subseteq S_2^P\).</strong></button>
  <div class="content">
<br>
In Lemma 2, I showed that LEX−FIRST−ACCEPTANCE (LFA) \(∈ \text{P}^\text{NP}\)-complete. Therefore, to show that \(P^\text{NP} ⊆ 𝑆_2^P\), we can instead just show that \(\text{LFA} ∈ S_2^P\) since \(\text{LFA}\) can then be generalized to all other languages in \(𝑃^{\text{NP}}\). Therefore, our goal is to show that for some predicate \(T\):<br>

$$1) ∀𝑥∈\text{LFA}, ∃𝑦∀𝑧, 𝑇(𝑥,𝑦,𝑧)=1$$
$$2) ∀𝑥∉\text{LFA}, ∃𝑧∀𝑦, 𝑇(𝑥,𝑦,𝑧)=0$$

Given an instance \((𝐶_1, 𝐶_2)\) of \(\text{LFA}\), we let \(𝜙(𝑥, 𝑦)\) be the lexicographically-first string (to be accepted by circuit \(𝐶_1\)) between \(x\) and \(y\). Therefore, we define the following predicate \(T\):
\(𝑇(𝑥, 𝑦, 𝑧) = 𝐶_2(𝜙(𝑥, 𝑦))\).<br><br>

In the case that \(𝐶_1(𝑥)\) and \(𝐶_1(𝑦)\) are both \(0\), there is no lexicographically-first string. In this case, we simply set \(𝑇(𝑥, 𝑦, 𝑧) = 0\). However, we can rewrite this as:

$$(𝐶_1,𝐶_2) ∈ \text{LFA} \Rightarrow ∃y∀z(∀x), T(x,y,z) = 1 \Rightarrow ∃y∀x, T(x,y)=1$$
$$(𝐶_1,𝐶_2) ∉ \text{LFA} \Rightarrow ∃z∀y(∀x), T(x,y,z) = 0 \Rightarrow ∃x∀y, T(x,y)=0$$

Since this is the definition of \(𝑆_2^𝑃\) (modified from above), this implies that \(\text{LFA} ∈ 𝑆_2^𝑃\). Hence, by the \(\text{P}^{\text{NP}}\)-completeness of \(\text{LFA}\), we have that: 

$$\text{P}^{\text{NP}} ⊆ 𝑆_2^P$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 4: \(\text{MA} \subseteq S_2^P\).</strong></button>
  <div class="content"><br>

\(∀ 𝐿_1 ∈ \text{MA}\), we have by definition that:

$$𝑥 ∈ 𝐿_1 ⇒ ∃𝑦, \Pr\limits_z [(𝑥,𝑦,𝑧)∈𝑅]≥\frac{2}{3}$$

$$𝑥 ∉ 𝐿_1 ⇒ ∀𝑦, \Pr\limits_z [(𝑥,𝑦,𝑧)∈𝑅]≤\frac{1}{3}$$

\(∀ 𝐿_2 ∈ 𝑆_2^P\), we have by definition that:

$$𝑥 ∈ 𝐿_2 ⇒ ∃𝑦∀𝑧, (𝑥,𝑦,𝑧)∈𝑅$$

$$𝑥 ∉ 𝐿_2 ⇒ ∃𝑧 ∀𝑦, (𝑥,𝑦,𝑧)∉𝑅$$

We can increase the probability of successfully accepting a “yes” instance through error reduction, from which we know that \(∀ 𝐿_1 ∈ \text{MA}, ∃𝑅 ∈ P\) such that:

$$𝑥 ∈ 𝐿_1 ⇒ ∃𝑦, \Pr\limits_z[(𝑥,𝑦,𝑧)∈𝑅]=1$$

$$𝑥 ∉ 𝐿_1 ⇒ ∀𝑦, \Pr\limits_z[(𝑥,𝑦,𝑧)∈𝑅]≤\frac{1}{3}$$

Similarly, we can successfully decrease the probability of incorrectly accepting a “no” instance through repeated error reduction which reduces the probability to:

$$𝑥 ∈ 𝐿_1 ⇒ ∃𝑦, \Pr\limits_z[(𝑥,𝑦,𝑧)∈𝑅]=1$$

$$𝑥 ∉ 𝐿_1 ⇒ ∀𝑦, \Pr\limits_z[(𝑥,𝑦,𝑧)∈𝑅]≤ \frac{1}{2^{|𝑦|}}$$

We claim then through these definitions that \(∀𝐿 ∈ \text{MA}, 𝐿 ∈ 𝑆_2^P\). To show that \(𝑥 ∈ 𝐿 ⇒ ∃𝑦, \Pr\limits_z[(𝑥, 𝑦, 𝑧) ∈ 𝑅] = 1\) is contained in \(𝑥 ∈ 𝐿_2 ⇒ ∃𝑦 ∀𝑧, (𝑥, 𝑦, 𝑧) ∈ 𝑅\): Since the probability of \((𝑥, 𝑦, 𝑧) ∈ R\) is \(1\) for all \(z\):

$$𝑥 ∈ 𝐿_1 ⇒ ∃𝑦, \Pr\limits_z [(𝑥,𝑦,𝑧)∈𝑅]=1$$

$$ ⇒ 𝑥 ∈ 𝐿_2 ⇒ ∃𝑦 ∀𝑧, (𝑥,𝑦,𝑧)∈𝑅$$

Using Boole’s inequality, we can take the union bound of the probability of incorrectly accepting a “no” instance of \(L\) across all possible values of \(y\) to get:

$$𝑥 ∉ 𝐿_1 ⇒ ∀𝑦, \Pr\limits_z [(𝑥,𝑦,𝑧)∈𝑅]≤ \frac{1}{2^{|y|}}$$

$$∈ ∃𝑦 \text{ such that }\Pr\limits_z [(x, y, z)∈𝑅] ≤ \frac{1}{2^{|y|}}\times 2^{|y|}$$

$$= ∃𝑦 \text{ such that }\Pr\limits_z [(x, y, z)∈𝑅] =1$$

$$∈ ∃ 𝑧 \text{ such that } ∀y(x, y, z)∉𝑅$$

$$𝑥 ∉ L_2 ⇒ ∃𝑧 ∀y, (x, y, z) ∉ 𝑅$$

These equations fits the necessary condition for all languages in \(𝑆_2^P\). Therefore, we have that:

$$∀ 𝐿 ∈ \text{MA}, \text{MA} ∈ 𝑆_2^P$$

$$\text{MA} ⊆ 𝑆_2^P$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 5: \(\text{BPP} \subseteq S_2^P\).</strong></button>
  <div class="content">
<br>

Lemma \(1\): \(\text{BPP} ⊆ \text{MA}\)<br><br>
<div class="single_indent">Given an arbitrary language \(\text{L} \in \text{BPP}\), we can show that there is an \(\text{MA}\) protocol that decides an instance \(x\):</div><br>

<div class="double_indent">Merlin (the prover) sends a single TRUE (\(1\)) bit (This is just a filler so that Merlin is doing something)</div><br>

<div class="double_indent">Arthur (the verifier) disregards Merlin’s bit and simulates the \(\text{BPP}\) machine for \(L\) on \(x\). </div>
<div class="double_indent">Note here that this is only possible since Arthur has the ability to flip coins and make random decisions.</div>
<div class="double_indent">If the \(\text{BPP}\) machine returns “TRUE”, Arthur returns “TRUE”.</div>
<div class="double_indent">If the BPP machine returns “FALSE”, Arthur returns “FALSE”.</div><br>

<div class="single_indent">Completeness and Soundness are intact here because Arthur simulates the \(\text{BPP}\) machine which has the same probabilities: </div>
<div class="double_indent">In particular, \(∀𝑥 ∈ L\), \(\Pr[𝑥 \text{ accepted}] ≥ \frac{2}{3}\) and \(∀𝑥 ∉ L\), \(\Pr[𝑥 \text{ rejected}] ≥ \frac{2}{3}\).</div><br>

<div class="single_indent">Therefore, any language in \(\text{BPP}\) has an \(\text{MA}\) protocol that decides it. Hence, \(\text{BPP} ⊆ \text{MA}\).</div><br>

<div class="single_indent">QED.</div><br>


Therefore, since we know that \(\text{BPP} ⊆ \text{MA}\), we can use the transitivity property and the result proven in Lemma 4 to obtain:<br>

$$\text{BPP} ⊆ \text{MA} ⊆ S_2^P$$

From this, we have that \(\text{BPP} ⊆ S_2^P\).<br><br>

QED.


<br><br><br>
</div><br>


<button class="collapsible"><strong>Lemma 6: If SAT has polynomial-sized circuits, then \(\text{PH} = S_2^P\).</strong></button>
  <div class="content">
<br>

It is known from the Cook-Levin theorem that \(\text{SAT} ∈ \text{NP-complete}\). Therefore, if \(\text{SAT}\) has polynomial-size circuits, then:

$$ \text{NP} \subseteq \text{P}/\text{poly}$$

To show that \(\text{PH} = S_2^P\), we need to show that:<br>
1) \(\text{PH} = \Sigma_2^P\)<br>
2) \(\text{PH} = \Pi_2^P\)<br><br>

In Lemma \(1\), we showed that \(\text{PH} \subseteq \Sigma_2^P \cap \Pi_2^P\). Therefore, the onus of this proof is to show that:<br>
1) \(\Sigma_2^P ⊆ \text{PH}\)<br>
2) \(\Pi_2^P ⊆ \text{PH}\)<br><br>

<u>Sub-Lemma 6.1</u>: \(\Sigma_2^𝑃 = \text{PH}\)<br>
<div class="single_indent">This follows from the regular Karp-Lipton theorem shown in Lemma 4.</div>
<div class="single_indent">Therefore, \(\Sigma_2^𝑃 ⊆ \text{PH}\) is trivially true.</div>
<div class="single_indent">QED.</div><br>

<u>Sub-Lemma 6.2</u>: \(\Pi_2^P ⊆ \text{PH}\):<br>
<div class="single_indent">Let \(𝐶\) be a family of circuits which output \(1\) on satisfiable inputs and \(0\) on unsatisfiable inputs.</div>
<div class="single_indent">Let \(C'\) be the family of circuits using self-reducibility of \(\text{SAT}\) instances to output satisfying assignments for \(\text{SAT}\) formulas.</div><br>

<div class="single_indent">Let \(L\) be an arbitrary language in \(\Pi_2^P\) and let \(𝜙\) be a predicate in \(P\). It follows then that:</div>

$$𝑥∈𝐿 ⇒ ∀𝑦∃𝑧, 𝜙(𝑥,𝑦,𝑧)=1$$

$$𝑥∉𝐿 ⇒ ∃𝑦∀𝑧, 𝜙(𝑥,𝑦,𝑧)=0$$

<div class="single_indent">However, note here that \(\{(𝑥, 𝑦) | ∃𝑧, φ(x, y, z) = 1\}\) is by definition in \(\text{NP}\) (where \(z\) is a witness).</div><br>

<div class="single_indent">Therefore, \(C'\) must exist to find satisfying assignments \(z\) for satisfying formulas \(x\).</div><br>

<div class="single_indent">We define the predicate \(𝜙'\) to be the polynomially verifiable instance \((𝐶, 𝑥, 𝑦)\).</div>
<div class="single_indent">Note that \((C,x,y)\) is \(\text{TRUE}\) if \(𝐶'(𝑥) = 𝑧\), where \(𝜙(𝑥, 𝑦, 𝑧) = 1\), and \(\text{FALSE}\) otherwise. </div><br>

<div class="single_indent">Therefore,</div>
$$𝑥∈𝐿⇒ ∃𝐶 \text{ such that }∀𝑦, 𝐶'(𝑥)=𝑧 \text{ such that } 𝜙'(𝑥,𝑦,𝑧)=1$$
$$𝑥∉𝐿⇒ ∀𝐶 \text{ such that }∃𝑦 ∀𝑧, 𝐶'(𝑥)=𝑧 \text{ such that } 𝜙'(𝑥,𝑦,𝑧)=0$$

<div class="single_indent">However, this can just be rewritten as:</div>

$$𝑥∈𝐿 ⇒ ∃𝐶∀𝑦, 𝜙'(𝐶,𝑥,𝑦)=1$$

$$𝑥∉𝐿 ⇒ ∃𝑦∀𝐶, 𝜙'(𝐶,𝑥,𝑦)=0$$

<div class="single_indent">Therefore, by definition \(𝐿 ∈ S_2^𝑃\). Since \(L ∈ \Pi_2^P\), we have that \(\Pi_2^P ⊆ S_2^P\).</div><br>

<div class="single_indent">QED.</div><br>

Therefore, since we have shown that

$$\Sigma_2^P ⊆ \text{PH},\quad \Pi_2^P ⊆ \text{PH},$$

and since we already know that

$$\text{PH} ⊆ \Sigma_2^𝑃 ∩ \Pi_2^P,$$

we now have that

$$\text{PH} = \Sigma_2^P \text{ and } \text{PH} = \Pi_2^𝑃.$$

Therefore,

$$S_2^P = \Pi_2^P = \Sigma_2^P.$$

This gives us:

$$\text{PH} = S_2^P$$

QED.

<br><br><br>
</div><br>


    </div>
  </div>
</div>



<style>

  .single_indent{
  text-indent: 50px;
}
.double_indent{
  text-indent: 100px;
}
.triple_indent{
  text-indent: 150px;
}

.quadruple_indent{
  text-indent: 200px;
}

.pentaple_indent{
  text-indent: 250px;
}

.hexaple_indent{
  text-indent: 300px;
}


.rectangle {
  height: 8%;
  width: 55%;
  background-color: black;
  margin-left: auto;
  margin-right: auto;
  color: white;
  display: flex;
  justify-content:center;
  align-items: center;
}

    .centertitleph112 {
      display: block;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

</style>
</head>
<div class="footer">
    <a href="#" class="w3-button w3-white w3-padding-large w3-margin-bottom"><img src="../up_arrow.png", style="width: 25px;height:25px";></i>To the top</a><br>
    <a href=https://www.instagram.com/emiletimothy/><img src="Pictures/icons/instagram-icon.png", alt="Instagram", style="width:25px;height:25px";></a>
    <a href=https://www.linkedin.com/in/emiletimothy/><img src="Pictures/icons/linkedin-icon.png", alt="Linkedin", style="width:25px;height:25px";></a>
    <a href=https://orcid.org/my-orcid?orcid=0000-0003-2893-9469https://orcid.org/my-orcid?orcid=0000-0003-2893-9469/><img src="Pictures/icons/orcid-icon.png", alt="Orcid", style="width:25px;height:25px";></a>
    <a href=https://scholar.google.com/citations?user=nUXwVU8AAAAJ&hl=en/><img src="Pictures/icons/googlescholar-icon.png", alt="Google Scholar", style="width:25px;height:25px";></a>
    <a href=https://github.com/emiletimothy/><img src="../Pictures/icons/github-icon.png", alt="Github Icon", style="width:30px;height:29px";></a><br><br>
<p1 style="color: white"><br><strong>© 2023 by Emile Timothy</strong></p1>
</div>

</body>

</html>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("b1-active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    }
  });
}
</script>



<style>
/* Style the button that is used to open and close the collapsible content */
.collapsible {
  background-color: #000000;
  color: #ffffff;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  outline: 10px white;
  border: none;
  text-align: center;
  outline: none;
  font-size: 15px;
}

.collapsible:after {
  background-color: #000000;
  content: '+'; /* Unicode character for "plus" sign (+) */
  font-size: 13px;
  outline: #000000;
  color: #ffffff;
  float: right;
  margin-left: 5px;
}

.b1-active:after {
  color: #ffffff;
  font-size:10px;
  content: "-"; /* Unicode character for "minus" sign (-) */
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.b1-active, .collapsible:hover {
  background-color: #000000;
}

.content {
  padding: 0 18px;
  color: black;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}
</style>
