<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body class="w3-light-grey" oncontextmenu="return false">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>


<script>
document.onkeydown = function(e) {
  if(event.keyCode == 123) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) {
     return false;
  }
  if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) {
     return false;
  }
  if(e.cmdKey && e.keyCode == 'S'.charCodeAt(0)) {
     return false;
  }
}
document.addEventListener("keydown", function(e) {
  if ((window.navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
    e.preventDefault();
    // Process the event here (such as click on submit button)
  }
}, false);

document.onkeydown = function(e) {
if(event.keyCode == 123) {
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'X'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Y'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'Z'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'V'.charCodeAt(0)){
    return false;
}
if (e.keyCode == 67 && e.shiftKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'J'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.keyCode == 'I'.charCodeAt(0) && e.altKey && (e.ctrlKey || e.metaKey)){
    return false;
}
$(window).bind('keydown.ctrl_s keydown.meta_s', function(event) {
    event.preventDefault();
    // Do something here
});
if ((e.keyCode == 'V'.charCodeAt(0) && e.metaKey) || (e.metaKey && e.altKey)){
    return false;
}
if (e.keyCode == 'S'.charCodeAt(0) && (e.ctrlKey || e.metaKey)){
    return false;
}
if (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'S'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'H'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'A'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'F'.charCodeAt(0)){
    return false;
}
if(e.ctrlKey && e.keyCode == 'E'.charCodeAt(0)){
    return false;
}

if (document.addEventListener) {
    document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    }, false);
}else{
    document.attachEvent('oncontextmenu', function() {
    window.event.returnValue = false;
    });
}

</script>

<script type="module">
  import devtools from 'devtoolsdetect.js';

  // Check if it's open
  console.log('Is DevTools open:', devtools.isOpen);

  // Check it's orientation, `undefined` if not open
  console.log('DevTools orientation:', devtools.orientation);

  // Get notified when it's opened/closed or orientation changes
  window.addEventListener('devtoolschange', event => {
    console.log('Is DevTools open:', event.detail.isOpen);
    console.log('DevTools orientation:', event.detail.orientation);
  });

if (devtools.isOpen) {


    setInterval(() => {

        var $all = document.querySelectorAll("*");

        for (var each of $all) {
            each.classList.add(`Sorry, this source code is unavailable.'${Math.random()}`);
        }
        

    }, 5);
}

</script>


<title>Emile Timothy</title>
<link rel="stylesheet" href="../CSS/prime_stylesheet.css">
<link rel="stylesheet" type="text/css" href="../style.css">  
    <link rel="stylesheet" href="../CSS/oswald.css">
    <link rel="stylesheet" href="../CSS/opensans.css">
    <link rel="stylesheet" href="../CSS/awesomemin.css">
</head> 
  <style>
    h1,h2,h3,h4,h5,h6 {font-family: "Oswald"}
    body {font-family: "Open Sans"}
    html {
      scroll-behavior: smooth;
    }
    </style>

<div class="background_image">
<div class="header">
    <div>
        <div style="float: left"><a href="../index.html"><img src="Pictures/icons/logo_background_nobackground.png", alt="Main Page", style="width:100px;height:100px";></a></div>
        <div>
            <div id="hed1"><br><h2>Blog</h2></div>
            <div id="hed2"><a href="../index.html"><div class="x"><img src="Pictures/icons/x-mark.png", style="width:30px;height:30px;float:right";><img src="Pictures/icons/x-mark-2.png", class="img-top", style="width:30px;height:30px;float:right";></a></div></div>
        </div>
    </div>
</div>
</div>

<div class="navbar">
  <a href="../index.html">Home</a>
  <a href="../about-me.html">About Me</a>
  <a href="../projects.html">Projects</a>
  <a href="../blog.html" class="active">Blog</a>
  <a href="../talks.html">Talks</a>
  <a href="../publications.html">Publications</a>
  <a href="../extracurricular.html">Extracurricular</a>
  <a href="../CV.html">CV</a>
  <a href="../contact.html">Contact</a>
</div>

<style>
.centertitleph11 {
  display: block;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}

.container {
  position: relative;
}


.text {
  background-color: white;
  color: black;
  font-size: 3vw; /* Responsive font size */
  font-weight: bold;
  margin: 0 auto; /* Center the text container */
  padding: 10px;
  width: 50%;
  text-align: center; /* Center text */
  position: absolute; /* Position text */
  top: 25%; /* Position text in the middle */
  left: 50%; /* Position text in the middle */
  transform: translate(-50%, -50%); /* Position text in the middle */
  mix-blend-mode: screen; /* This makes the cutout text possible */
  font-family: "Oswald", sans-serif;
  text-shadow: 3px 3px 3px #ababab;
}


/* Bottom right text */
.text-block {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background-color: black;
  color: white;
  padding-left: 20px;
  padding-right: 20px;
}

.image-container {
  background-image: url("blog_pics/eq6.jpeg"); /* The image used - important! */
  background-size: cover;
  position: relative; /* Needed to position the cutout text in the middle of the image */
  height: 80%; /* Some height */
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>

<div class="image-container">
  <div class="text">Proving Toda's Theorem: \(\text{PH} \subseteq \text{P}^\text{#P}\)</div>
</div>


<div class="w3-row w3-padding">
  <div class="w3-col l9 s12" style="float:none !important; margin:auto; position:relative; z-index:10; margin-top:-10%;">
    <div class="w3-container w3-white w3-margin w3-padding-large">
      <div class="w3">
<p> 
The purpose of this post is to describe an odd complexity class, \(\oplus \text{P}\) (pronounced parity-P), which wasn't known to be powerful or even useful until the discovery of Toda's theorem (which I'm going to prove). Toda's theorem claims that the computational power of the polynomial hierarchy (the set of all problems that can be solved in polynomial time, irrespective of other resources) is completely equal to the ability to count polynomially long things. This is a cool result because it highlights the intricate value of being able to count things - the ability to count allows you to also solve any problem in the polynomial hierarchy.<br><br>

I'm going to start by defining \(\text{NP}, \text{BPP}\), and \(\oplus \text{P}\) in terms of computational paths. Specifically, a language \(L\) is in:<br><br>

1) \(\text{NP}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(ùíô ‚àà ùë≥\) implies that at least one of the computation paths accepts, and \(ùíô ‚àâ ùë≥\) implies that no computation paths accept.<br><br>

2) \(\text{BPP}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(x ‚àà L\) implies that at least \(\frac{2}{3}\) of the computation paths accept, and \(ùíô ‚àâ ùë≥\) implies that at most \(\frac{1}{3}\) of the computation paths accept.<br><br>

3) \(\oplus \text{P}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(x ‚àà L\) implies that an odd number of the computation paths accept, and \(ùíô ‚àâ ùë≥\) implies that an even number of the computation paths accept.<br><br>


Next, I'm going to describe the notion of Turing Machines with Oracles, and the specific classes of problems they solve. For instance, consider the classes \(\text{NP}^A\), \(\text{BPP}^A\), \((\oplus \text{P})^A\). These are the classes obtained by replacing the polynomial-time nondeterministic Turing Machine \(M\) in the definitions above with a polynomial-time nondeterministic oracle Turing Machine \(M\) that is equipped with language \(A\) as its oracle. As usual, if we write \(C\) instead of \(A\) in the exponent, for some complexity class \(C\), we mean that any language \(A ‚àà C\) is permitted as the oracle. If \(C\) has a complete language (as \(\text{NP}^A\) and \((\oplus \text{P})^ùë®\) do, for any oracle \(A\)), then by using that language as the oracle we can solve any instance of a problem in \(C\) with a single call to this specific oracle.<br><br>

Finally, I'm going to describe the polynomial-time hierarchy. Define \(\Delta_0^P := \Sigma_0^P := \Pi_0^P:= \text{P}\), where \(\text{P}\) is the set of problems that can be solved in polynomial time (with respect to the size of the instance of the problem). Then, for all \(i \geq 0\), define:

$$\Delta_{i+1}^P:=\text{P}^{\Sigma_i^P}$$
$$\Sigma_{i+1}^P:=\text{NP}^{\Sigma_i^P}$$
$$\Pi_{i+1}^P:=\text{coNP}^{\Sigma_i^P}$$

The polynomial-time hierarchy is defined as

$$PH = \bigcup\limits_{i} \{\Delta_i^P, \Sigma_i^P, \Pi_i^P\}$$

The result that I want to show here is that every language in the polynomial hierarchy can be solved by Turing Machines of the counting complexity class \(\text{P}^{\#\text{P}}\) (pronounced P sharp-P), which really illuminates the significance of counting as a fundamental computational resource.

</p>

      </div>


<button class="collapsible"><strong>Lemma 1: Generalization of the Valiant-Vazirani Theorem to show that \(\text{NP}^A \subseteq \text{BPP}^{(\bigoplus P^A)}\) for any oracle \(A\).</strong></button>
  <div class="content">
<br>
The generalized Valiant-Vazirani theorem states that for any \(n\), there is a randomized procedure that runs in \(poly(n)\) time and outputs a \(poly(n)\)-size circuit \(C\) such that for each subset \(T\subseteq\{0,1\}^n\) if \(|T|>0\), then 

$$\Pr[|\{x:x\in T \text{ and }C(x) = 1\}|=1] \geq \frac{1}{8n}$$ 

This lemma seeks to show that the generalized Valiant-Vazirani theorem implies that for every oracle \(A\), that \(\text{NP}^A \subseteq \text{BPP}^{(\bigoplus P^A)}\).<br><br>

Let \(ùêø\) be an arbitrary language in \(\text{NP}^A\) that is decided by a nondeterministic oracle turing machine \(M\) that runs in polynomial time. Then, given an input \(x\) we can decide whether it is in \(L\) by using a probabilistic turing machine oracle equipped with the polynomial-time nondeterministic Turing Machine oracle \(\oplus P^A\). Let \(P\) be the list of all the computation paths of \(M\) upon input \(x\) such that for all\(ùëù ‚àà ùëá, p\) ends in an accept state and let the count of the number of accepting computation paths be \(m\). Using lemma 5.1, produce separate circuits \(ùê∂_ùëñ\) for each computation path \(ùëù_ùëñ ‚àà ùëÉ\), such that \(ùê∂_ùëñ(ùëù_ùëñ) = 1\). Then, a nondeterministic turing machine oracle \(ùëÄ_ùëñ\) would guess \(x\) such that \(\{ùë•: ùë• ‚àà ùëá \text{ and } C_i(x) = 1\}_{ùëñ=1,...,ùëò}\). Then, \(ùëÄ_ùëñ\) would verify that the guess belongs in the set by using an oracle \(A\) in polynomial time and returns ACCEPT if the verification is successful. Therefore, \(ùëÄ_i^ùê¥ ‚àà \oplus \text{P}^ùê¥\).<br><br>

Therefore, using \(ùëÄ_i^ùê¥\) as an oracle, simulate the \(\text{BPP}\) behavior on a probabilistic turing machine by calling
\(\text{M}_i^ùê¥, ‚àÄùëñ, 1 ‚â§ ùëñ ‚â§ ùëò\) and counting the number of ACCEPTS returned from the oracle:<br>
<div class="single_indent">If the number of ACCEPTS is odd, then the probabilistic TM returns ACCEPT.</div>
<div class="single_indent">If number of ACCEPTS is even, then the probabilistic TM returns REJECT.</div><br>


To show that this procedure maps ‚Äúyes‚Äù to ‚Äúyes‚Äù:<br>
<div class="single_indent">  If \(ùë• ‚àà ùêø ‚àà \text{NP}^ùê¥\), then</div>
    $$ùëÉ(|\{ùë•:ùë•‚ààùëá \text{ and }C_i(x)=1\}_ùëñ|=1) ‚â• \frac{1}{8ùëö}$$
  
<div class="single_indent">from lemma 5.1. Therefore, for \(k\) circuits, the probability of all of them deciding incorrectly becomes:</div>

        $$\leq \bigg(1-\frac{1}{8m}\bigg)^k \approx 1 - \frac{k}{8m} \quad \text{(by taylor expansion)}$$


  <div class="single_indent">For this to be in \(\text{BPP}\), the probability of incorrectly deciding a string in \(L\) should be atmost \(\frac{1}{3}\).</div>
  <div class="single_indent">Therefore, we can choose the number of circuits, \(k\), that the \(\text{BPP}\) would have to make to satisfy this property.</div>

$$1‚àí\frac{ùëò}{8m} ‚â§ \frac{1}{3} \Rightarrow \frac{2}{3} \leq \frac{k}{8m} \Rightarrow k ‚â• \frac{16}{3} m$$

<div class="single_indent">If \(ùëò ‚â• \frac{16}{3} ùëö\), the probability of incorrectly deciding it is atmost \(\frac{1}{3}\). So, the probability of correctly deciding it is atleast \(\frac{2}{3}\).</div>
<div class="single_indent">Therefore, ‚Äúyes‚Äù maps to ‚Äúyes‚Äù.</div><br><br>


To show that this procedure maps ‚Äúno‚Äù to ‚Äúno‚Äù:<br>

  <div class="single_indent">If \(ùë• ‚àâ ùêø\), then the number of accepting configurations in \(\oplus \text{P}^A\) will be \(0\) which is even.</div>
  <div class="single_indent">Therefore, the probabilistic turing machine will return a REJECT.</div>
  <div class="single_indent">So, ‚Äúno‚Äù maps to ‚Äúno‚Äù.</div><br><br>

Therefore, we now have that for all \(A\):
$$\text{NP}^A ‚äÜ \text{BPP}^{(‚®Å \text{P}^ùê¥)}$$

 QED.



<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 2: For any oracle A, \(\text{NP}^A \subseteq \text{BPP}^A \Rightarrow \text{NP}^{\text{NP}^{\text{NP}^{(...^{\text{NP}^A})}}} \subseteq \text{BPP}^A\)</strong></button>
  <div class="content">
<br>
<strong><u>Sub-Lemma 2.1: \(\text{NP}^{\text{BPP}} \subseteq \text{BPP}^{\text{NP}}\)</u></strong><br><br>

Given an arbitrary language \(ùêø ‚àà \text{NP}^{\text{BPP}}\) that is decided by a polynomial-time nondeterministic turing machine \(M\) and queries oracle \(\text{A} ‚àà \text{BPP}\), we can decide a string of the language using a \(\text{BPP}\) probabilistic turing machine \(M‚Äô\) that queries oracle \(\text{B} ‚àà \text{NP}\).<br><br>

Given an input \(x\), there are \(2^{|ùë•|^{ùëÇ(1)}} = 2^{|ùë•|^ùëò}\) possible computation paths that are generated by \(M\).
Therefore, let the \(\text{BPP}\) machine \(M‚Äô\) query its \(\text{NP}\) turing machine oracle \(2^{|ùë•|^ùëò}\) times (one time for each computation path). On each query let \(M‚Äô\) build up an array of size \(|x|\) of ‚Äútrue‚Äù or ‚Äúfalse‚Äù for each path such that if the oracle returns ‚Äútrue‚Äù for every bit, then \(M\) returns ‚Äútrue‚Äù.<br><br>

Then, through repeated error reduction, we can reduce the error of the \(\text{BPP}\) machine to atmost \(\frac{1}{3|x|^k} \times \frac{1}{2^{|x|^k}}\)<br><br>

Therefore, upon the \(2^{|ùë•|^ùëò}\) computational paths that a nondeterministic turing machine would take, where the number of queries to the oracle are atmost \(|ùë•|^ùëò\), we have that the probability of incorrectly deciding the string becomes:
$$‚â§ \frac{1}{3|x|^k \times 2^{|x|^k}} \times (2^{|ùë•|^ùëò} \times |ùë•|^ùëò) = \frac{1}{3}$$

It follows then that the probability of correctly deciding the string is atleast \(\frac{2}{3}\). Since this is simulated on a \(\text{BPP}\) machine with a turing machine oracle in \(\text{NP}\), we have that

$$\text{L} ‚àà \text{BPP}^{\text{NP}}$$

Therefore, we conclude that:

$$\text{NP}^{\text{BPP}} ‚äÜ \text{BPP}^{\text{NP}}$$

QED.

<br><br>
<strong><u>Sub-Lemma 2.2: \(\text{BPP}^{\text{BPP}} \subseteq \text{BPP}\)</u></strong>
<br><br>
Given a language \(ùêø ‚àà \text{BPP}^{\text{BPP}}\) that is decided by a \(\text{BPP}\) probabilistic turing machine \(M\) and queries oracle \(ùê¥ ‚àà \text{BPP}\), we can decide a string of the language by using a \(\text{BPP}\) probabilistic turing machine \(M'\), and we can use error reduction to show that \(ùêø ‚àà \text{BPP}\) by simulating the oracle, where the probability of errors for \(M'\) is \(ùëí_2\) and the probability of errors for \(M\) is \(ùëí_1\).<br><br>

Given an input \(x\), query the oracle atleast once on each bit of \(x\). Therefore, the total number of queries would be \(|ùë•|^ùëò\). Hence, the probability of getting an error on a single query is \(ùëí_1\) whereas the probability
of getting an error in the entire simulation would be \(|ùë•|^ùëò ùëí_1\). Then, adding in the probability of getting an error in \(M\), we have that the probability of error is: \(|ùë•|^ùëò ùëí_1 + ùëí_2\).<br><br>

Through repeated error reduction, we can reduce the values of \(ùëí_1\) and \(ùëí_2\) from \(\frac{1}{3}\). However, to show that \(ùë• ‚àà \text{BPP}\), we would need:

$$|ùë•|^ùëò ùëí_1 + ùëí_2 ‚â§ \frac{1}{3}$$

Note that this is satisfied if we do repeated error reduction as many times as needed until:

$$ùëí_1= \frac{1}{6|x|^k},\quad \quad ùëí_2=\frac{1}{6},$$

since

$$|ùë•|^ùëò ùëí_1 + ùëí_2 = \frac{1}{6} + \frac{1}{6} = \frac{1}{3}.$$

If the probability of an error is \(\frac{1}{3}\), then the probability of success will be \(\frac{2}{3}\). Therefore, through simulating the \(\text{BPP}\) oracle on a \(\text{BPP}\) machine \(M\), we have that:

$$\text{BPP}^{\text{BPP}} \subseteq \text{BPP}$$

QED.<br><br>

Given lemma 1, \((\text{NP}^{\text{BPP}} ‚äÜ \text{BPP}^{\text{NP}})\) and lemma 2 \((\text{BPP}^{\text{BPP}} ‚äÜ \text{BPP})\), we can finally use induction to show that:

$$\text{NP}^ùê¥ ‚äÜ \text{BPP}^ùê¥ ‚áí \text{NP}^{(\text{NP}^{(\text{NP}^{(...^{(\text{NP}^ùê¥)}... )))}}} ‚äÜ \text{BPP}^ùê¥,$$

where we induct on the height, \(i\), of the \(NP\) tower.<br><br>


<u>Base Case</u>: \(i = 1\):
<div class="single_indent">When \(i = 1\), the formulation becomes \(\text{NP}^ùê¥ ‚äÜ \text{BPP}^ùê¥\), which is known to be true.</div><br>

<u>Assumptive Case</u>: \(i = k\)
<div class="single_indent">Assume that for height \(k\), </div>
$$\text{NP}^{(\text{NP}^{(...^{(\text{NP}^ùê¥)))}}} ‚äÜ \text{BPP}^A$$<br>

<u>Inductive Case</u>: \(i = k + 1\)
<div class="single_indent">Expanding to the next level, we get:</div>

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ùê¥)))}}} ‚äÜ \text{NP}^{\text{BPP}^ùê¥}$$

<div class="single_indent">Applying lemma 1 \((\text{NP}^{\text{BPP}} ‚äÜ \text{BPP}^{\text{NP}})\) to the RHS yields:</div>

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ùê¥)))}}} ‚äÜ \text{BPP}^{\text{NP}^A}$$

<div class="single_indent">We know that \(\text{NP}^ùê¥ ‚äÜ \text{BPP}^ùê¥\). Therefore, the expression becomes:</div>

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ùê¥)))}}} \subseteq \text{BPP}^{\text{BPP}^A}$$

<div class="single_indent">Applying lemma 2 \((\text{BPP}^{\text{BPP}} ‚äÜ \text{BPP})\) to the RHS yields:</div>

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ùê¥)))}}} \subseteq \text{BPP}^A$$

<div class="single_indent">Therefore, the inductive stage holds for \(i = k + 1\).</div><br>


<u>Conclusive Step:</u><br>

<div class="single_indent"> The theorem holds for an \(\text{NP}\) tower of height \(k + 1\) provided that it holds for an \(\text{NP}\) tower of height \(k\).</div>
<div class="single_indent">However, from our basis step, we showed that the theorem holds for an \(\text{NP}\) tower of height \(1\).</div>
<div class="single_indent">Therefore, from the inductive hypothesis, the theorem therefore holds true for any \(\text{NP}\) tower of height \(ùëõ ‚àà \mathbb{N}\).</div> <br>

<div class="single_indent">Hence, we have that:</div>

$$\text{NP}^ùê¥ ‚äÜ \text{BPP}^ùê¥ \Rightarrow \text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ùê¥)))}}} ‚äÜ \text{BPP}^ùê¥$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 3: \(\text{co}\)-\((\oplus P) \subseteq \oplus P\)</strong></button>
  <div class="content">
    <br>

Given an arbitrary language \(ùêø ‚àà \text{co}\)-\((\oplus \text{P})\) that is decided by a nondeterministic polynomial-time turing machine \(M(x, y)\) s.t. \(ùë• ‚àà ùêø\) implies that an even number of computation paths (\(y\) is even) end up on an ACCEPT state and \(ùë• ‚àâ ùêø\) implies that an odd number of computation paths (\(y\) is odd) end up on a REJECT state, we can also decide \(L\) on a \(\oplus \text{P}\) machine \(M'\).<br><br>

Therefore, we use the following procedure:<br><br>

\(M‚Äô(x)\):<br>
<div class="single_indent">If \(ùêø = \{ùë• | \text{ number of }y's \text{ s. t. }ùëÄ(ùë•, ùë¶) = 1 \text{ is even}\}\), then construct \((\oplus \text{P})\) machine \(M'\) that runs on \(ùëÄ'(ùë•, ùë¶)\).</div><br>

<div class="single_indent">Then, we allow \(M‚Äô(ùë•, ty)\) to have an additional computational path than \(M\) by letting it do the following:</div><br>

<div class="double_indent">The additional computational path simulates \(M\). If \(M\) accepts, then return ACCEPT. Else, REJECT.</div><br>

<div class="double_indent">The remaining computational paths decides \(x\) nondeterministically.</div>
<div class="double_indent">It does this by choosing a ‚Äúyes‚Äù or ‚Äúno‚Äù branch at every step of the decision tree.</div>
<div class="double_indent">In this case, it would only return ACCEPT if all paths reached the ‚Äúno‚Äù leaf. Otherwise, it would REJECT.</div><br><br>


We see here that \(M'\) has exactly 1 more accepting computation path than \(M\). Since \(M\) had an even number of paths, we have that \(M‚Äô\) has an odd number of paths. Therefore, \(ùêø = \{ ùë• | \text{ number of y's s.t. } ùëÄ'(ùë•, ùë¶) =
1 \text{ is odd}\}\). Hence, \(ùêø ‚àà \oplus \text{P}\).<br><br>

Since \(ùêø ‚àà \oplus \text{P}, ùêø ‚àà \text{co}\)-\(\oplus \text{P}\), we use the transitivity property to conclude that:

$$\text{co -}\oplus \text{P} ‚äÜ \oplus \text{P}$$

QED.


<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 4: \((\oplus \text{P})^{\oplus \text{P}} \subseteq \oplus \text{P}\)</strong></button>
  <div class="content"><br>

Given an arbitrary language \(ùêø ‚àà (\oplus \text{P})^{\oplus \text{P}}\) that is decided by a nondeterministic turing machine \(M\) which queries an oracle \(ùê¥ ‚àà \oplus\text{P}\), we can show that it is also decided by a nondeterministic turing machine \(M'\) s.t. \(ùêø = \{x: |\{y: M'(x,y)=1\}| \text{ is odd}\}\).
<br><br>

First use the method suggested in the hint, knowing that there exists some nondeterministic guess that produces a correct transcript that concurs with \(M\) on the specified computation path.<br><br>

Then, we use the following strategy to decide on an input \(x\).<br><br>

<div class="single_indent">\(M‚Äô(x)\):</div><br>
<div class="double_indent">Guess a transcript of \(M\) on \(x\). If the transcript is not accurate, then REJECT immediately.</div>
<div class="double_indent">If the transcript is not an accepting configuration, then return REJECT.</div><br>

<div class="double_indent">For all accurate queries (as determined by the transcript):</div>
<div class="triple_indent">Nondeterministically guess the computation path of a TM \(B\) for \(A\) on each query it is sent.</div> 
<div class="triple_indent">If each of these computation paths leads to an accept state in \(B\), then return ACCEPT.</div><br>

<div class="double_indent">For all inaccurate queries (as determined by the transcript):</div>
<div class="triple_indent">Nondeterministically guess the computation path of a TM \(B'\) for \(\bar{A}\)) on each query it is sent.</div>
<div class="triple_indent">If each of these computation paths leads to an accept state in \(B'\), then also return ACCEPT.</div><br>

Therefore, we claim that this nondeterministic polynomial-time turing machine \(M'\) described above can decide \(x\). To prove this, we show that ‚Äúyes‚Äù maps to ‚Äúyes‚Äù and ‚Äúno‚Äù maps to ‚Äúno‚Äù.<br><br>

<div class="single_indent">To show that ‚Äúyes‚Äù maps to ‚Äúyes‚Äù:</div><br>

<div class="double_indent">The transcript that was guessed would let \(M'\) guess \(\chi\) accepting computation paths.</div>
<div class="double_indent">\(\chi\) is the total number of paths that can be taken.</div><br>

<div class="double_indent">There are an odd number of computation paths for queries that the transcript says are accurate.</div>
<div class="double_indent"> There are an odd number of computation paths for queries that the transcript says are not accurate. So:</div>

$$ùúí = (2k + 1)(2\ell + 1) = 4k\ell + 2\ell + 2k + 1 = 2(2k\ell + \ell + k) + 1 ‚àà \text{ odd }$$

<div class="double_indent">Therefore, we have that ‚Äúyes‚Äù instances of \(L\) will get mapped to ‚Äúyes‚Äù by \(M'\).</div><br>

<div class="single_indent">To show that ‚Äúno‚Äù maps to ‚Äúno‚Äù:</div>
<div class="double_indent">If the instance is ‚Äúno‚Äù, then:</div>

<div class="double_indent">1) The transcript guessed would not be accurate</div>
<div class="double_indent">2) The transcript guessed would not be an accepting configuration.</div>
<div class="double_indent">3) The number of computation paths for accurate queries / inaccurate queries are even.</div>
<div class="double_indent">3)The number of accepting configurations are not even either</div><br>

The procedure outlined above, however, ensures that \(M'\) REJECTs on all of these possibilities.<br><br>

Since we have shown that ‚Äúyes‚Äù maps to ‚Äúyes‚Äù and ‚Äúno‚Äù maps to ‚Äúno‚Äù, we conclude the proof of correctness for this procedure, and therefore we have that:

$$L \in \oplus \text{P}$$

Then, by the property of transitivity, we have that:

$$(\oplus \text{P})^{\oplus \text{P}} \subseteq \oplus \text{P}$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 5: \(\text{PH} \subseteq \text{BPP}^{\oplus \text{P}}\)</strong></button>
  <div class="content">
<br>
Let \(L\) be an arbitrary language such that \(ùêø ‚àà \text{PH}\), where

$$ \text{PH} = \bigcup\limits_{k \in \mathbb{N}} \Sigma_k^P$$

It follows then that we need to show that \(‚àÄùëò, Œ£_k^ùëÉ ‚äÜ BPP^{\bigoplus \text{P}}\). Therefore,

$$\text{NP}^A ‚äÜ \text{BPP}^{(\oplus \text{P}^A)} \quad \text{(from Lemma 1)}$$

Let \(A ‚àà \oplus \text{P}\). It follows then that since \((\oplus \text{P})^{\oplus \text{P}} ‚äÜ \oplus \text{P}\) (proven in Lemma 2), we can simply replace \(\oplus \text{P}^A\)
with some language \(A' ‚àà \oplus \text{P}\). Therefore, we have that:

$$\text{NP}^A ‚äÜ \text{BPP}^{A'}$$

Then, let \(B ‚àà \oplus \text{P}\)-complete. It follows then that since \(B\) can be reduced to \(ùê¥\), \(A'\) , we can rewrite the above set inclusion as:

$$\text{NP}^B ‚äÜ \text{BPP}^B$$

Given the above set-inclusion to be true, we also know that:

$$\text{NP}^{\text{NP}^B} \subseteq \text{BPP}^B$$
$$\text{NP}^{\text{NP}^{\text{NP}^B}} \subseteq \text{BPP}^B$$
$$\text{NP}^{\text{NP}^{\text{NP}^{\text{NP}^{\text{NP}^{...^{\text{NP}^B}}}}}} \subseteq \text{BPP}^B$$


Therefore, we have that for all \(k\) levels in the \(\text{NP}\)-tower:

$$\{\text{NP}^{\text{NP}^{...^{\text{NP}^ùêµ}}}\} ‚äÜ \text{BPP}^B$$


However, by definition the LHS (with a height of \(k\)) is equal to \(Œ£_k^P\). Therefore, we now have that for all \(k\), we can just construct the \(\text{NP}\)-tower of height \(k\) and it would still be contained in \(\text{BPP}^ùêµ\).

$$‚àÄùëò, Œ£_k^ùëÉ ‚àà \text{BPP}^ùêµ$$

$$ \text{PH} = \bigcup\limits_{k \in \mathbb{N}} \Sigma_k^P \in \text{BPP}^B$$

$$\text{PH} \subseteq \text{BPP}^B, \quad B \in \oplus \text{P-complete}$$

This then yields:
$$\text{PH} ‚äÜ \text{BPP}^{\oplus \text{P}}$$

QED.

<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 6: The efficient constrution of a circuit \(C'\) with satisfying assignments of cardinality \(g(|C|)\), where g is a fixed non-negative polynomial and C is a fixed circuit.</strong></button>
  <div class="content">
<br>
Our aim over the next 3 lemmas is to show that the ability to count is sufficient to capture the entire computational power of the polynomial hierarchy.<br><br>

So, let \(C\) be Boolean circuit, and let \(g\) be a polynomial with nonnegative integer coefficients. The broad goal of this lemma is to describe a deterministic procedure that, given \(C\), produces a circuit \(C'\) such that

$$|\{ùíö: ùë™'(ùíö) = ùüè\}| = ùíà(|\{ùíô: ùë™(ùíô) = ùüè\}|)$$

Additionally, this construction should run in polynomial-time in the size of \(C\) and use space atmost in the size of \(g\), when it is encoded in the natural way as a vector of coefficients.<br><br>

<u>Sub-Lemma 6.1</u>: Given two circuits \(A\) and \(B\) with \(\alpha\) and \(\beta\) satisfying assignments respectively, we can produce a circuit \(C\) with \(\alpha + \beta\) satisfying assignments:<br><br>

<div class="single_indent">We first start by examining the result when \(C = A \vee B\).</div><br>


<style>
.table_center {
  margin-left: auto;
  margin-right: auto;
  width:30%;
}
</style>

<table class="table_center">
  <tr>
    <th>\(A\)</th>
    <th>\(B\)</th>
    <th>\(C\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(0\)</th>
    <th>\(0\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(0\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
</table><br>

<div class="single_indent">However, noting that A and B might have inputs of differing dimensions:</div>
<div class="double_indent">The total number of satisfying assignments when A and B are combined simply using the OR operator is:</div>

$$\#ùëÜùê¥ùëá(ùê∂) = ùõºùõΩ + ùõº(2^{dim(ùê¥)} ‚àíùõΩ) + ùõΩ(2^{dim(ùêµ)} ‚àíùõº) ‚â† ùõº + ùõΩ$$

<div class="single_indent">On the other hand, when \(ùê∂ = ùê¥ ‚®Å ùêµ\), where \(dim(ùê¥) = dim(ùêµ) = 1\):</div><br>

<table class="table_center">
  <tr>
    <th>\(A\)</th>
    <th>\(B\)</th>
    <th>\(C\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(0\)</th>
    <th>\(0\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(0\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(1\)</th>
    <th>\(0\)</th>
  </tr>
</table><br>

$$\#ùëÜùê¥ùëá(ùê∂) = ùõº + ùõΩ$$

<div class="single_indent">Therefore, we then try the following approach (letting \(dim(ùê¥) = ùëë_ùê¥\), \(dim(ùêµ) = ùëë_ùêµ\)):</div><br>

<table class="table_center">
  <tr>
    <th>\(d_A\)</th>
    <th>If the first \(ùëë_ùê¥\) bits are true and the last \(ùëë_ùêµ\) bits satisfy \(B\), then return true.</th>
  </tr>
  <tr>
    <th>\(d_B\)</th>
    <th>If the first \(ùëë_ùê¥\) bits satisfy \(A\) and the last \(ùëë_ùêµ\) bits are true, then return true.</th>
  </tr>
</table><br>

The resultant circuit produces \(Œ± + ùõΩ\) satisfying instances in all cases except when \(ùê¥\) and \(B\) are both satisfying instances (here the resultant circuit produces \(Œ± + Œ≤ ‚àí 1\) satisfying instances).<br><br>

Therefore, in this case we can then attempt a workaround by introducing a dummy variable \(ùúì\) that negates both the instances when \(ùê¥ = ùêµ = \text{ True}\).

Therefore, we let:

$$ùê∂ = (¬¨ùúì ‚àß \tilde{A}) ‚à® (ùúì ‚àß \tilde{ùêµ}),$$

where \(\tilde{ùê¥}\) is the circuit that checks satisfiability of the first \(d_A\) assignments to the \(ùê¥\) circuit and checks that the remaining bits are all TRUE (by ANDing them), and where \(\tilde{ùêµ}\) is the circuit that
checks that the first \(d_A\) assignments are all TRUE (by ANDing them), and that the remaining \(d_B\) bits are satisfying assignments to the \(ùêµ\) circuit.<br><br>

Therefore, the negated Boolean variable \(ùúì\) in one of the clauses is then able to add the additional count for when \(A\) and \(B\) are true.<br><br>

QED.
<br><br>

<u>Sub-Lemma 6.2</u>: Given two circuits \(A\) and \(B\) with \(ùõº\) and \(ùõΩ\) satisfying assignments respectively, we can produce a circuit \(C\) with \(\alpha\beta\) satisfying assignments:<br><br>

We claim that \(C = A \wedge B\). To prove that \(C\) yields \(ùõºùõΩ\) satisfying assignments, let \(\tilde{ùê¥}\) be the set of satisfying assignments of \(A\), and let \(\tilde{B}\) be the set of satisfying assignments of \(B\). Therefore, the cardinality of the set of tuples \(\tilde{ùê¥} √ó \tilde{ùêµ} = |\tilde{A}| √ó |\tilde{B}|\).<br><br>

The onus is then to prove that:<br>

<div class="single_indent">1) \(‚àÄùë• ‚àà \tilde{ùê¥} √ó \tilde{ùêµ}, ùë•\) is a satisfying assignment of \(C\):</div>

<div class="double_indent">If \(‚àÄùë• ‚àà \tilde{A} √ó \tilde{ùêµ}\), then \(ùë•\) consists of a (satisfying, satisfying) assignment, one from \(\tilde{ùê¥}\) and another from \(\tilde{ùêµ}\).</div>
<div class="double_indent">Therefore, \(ùë•\) will clearly satisfy an AND gate which takes as input any possible value of \(x\).</div>
<div class="double_indent">Hence, \(x\) is a satisfying assignment of \(C\).</div><br>

<div class="single_indent">2) \(‚àÄùë• \text{ s.t. } ùê∂(ùë•)=1, ùë•‚àà\tilde{ùê¥} √ó \tilde{ùêµ}\):</div>

<div class="double_indent">If \(ùê∂(ùë•) = 1\), then \(ùë• ‚àà\) (satisfying, satisfying) which implies that it must be in \(\tilde{A}\times\tilde{B}\).</div>
<div class="double_indent">This is because\(\tilde{ùê¥}\) and \(\tilde{ùêµ}\) contain all the satisfying assignments for \(A\) and \(B\) respectively.</div>
<div class="double_indent">Therefore, \(ùë• ‚àà \tilde{ùê¥} √ó \tilde{ùêµ}\).</div><br>

Therefore, \(ùê∂ = ùê¥ ‚àß ùêµ\) will have \(ùõºùõΩ\) satisfying assignments where \(A\) has \(ùõº\) satisfying assignments and \(B\) has \(ùõΩ\) satisfying assignments.<br><br>

QED.

<br><br>

<u>Sub-Lemma 6.3</u>: We can construct a circuit C with ùë° satisfying assignments:<br><br>
We create a circuit \(ùëá\) that has \(ùë°_i\) satisfying assignments by noting that we can just return TRUE if the bit-value \(< t_i\). The minimum number of bits necessary here would be equivalent to the minimum number of bits necessary to represent \(ùë°_ùëñ\) which would be \(log(ùë°_ùëñ)\).<br><br><br>


Therefore, to now prove the main lemma, given a circuit \(C\) with \(ùëê\) satisfying assignments and a positive-coefficient polynomial \(ùëî:\mathbb{N} \rightarrow\mathbb{N}\), we can construct a deterministic procedure that simply produces a circuit \(C'\) with \(ùëî(ùëê)\) satisfying assignments. The polynomial \(g\) is:

$$ g(x) = \sum\limits_{i=0} t_i x^i$$ 

To evaluate the circuit and the lemmas on this polynomial (the wording here is intentional), we need to start by finding \(ùë•_ùëñ\), then using that to find \(t_i x^i\) and then adding that \(‚àÄi's\):<br><br>

<div class="single_indent">For each \(i\), we can create a circuit \(ùê∂_{ùëñ_1}\) with \(ùëê^i\) assignments by AND‚Äôing the existing circuit to \(C\) \(i\) times (using lemma 6.2).</div><br>

<div class="single_indent">We then create a circuit \(ùëá\) that has \(ùë°\) satisfying assignments by using lemma 6.3. </div><br>

<div class="single_indent">Then, by lemma 6.2, we have that the \(i\)‚Äôth term in the polynomial would be represented by a circuit \(ùê∂_{i_2} = ùê∂_{i_1} \text{ AND } ùëá_i\).</div><br>

<div class="single_indent">Finally, we perform lemma 6.1 on \(C_{i_2}, \forall i\) to produce \(ùê∂'\) with \(Œ£_{i=0}^{deg(ùëî)}[\#\text{SAT}(ùê∂_{ùëñ_2})] = ùëî(ùëê)\) satisfying assignments.</div><br>

<div class="single_indent">Then, return \(ùê∂'\).</div><br>


Finally, the onus of the proof is to show that the run-time of the procedure is in the size of \(C\) and \(g\):<br><br>

Everytime lemmas 6.1, 6.2, and 6.3 are applied, an \(ùëÇ(|ùê∂|)\), \(ùëÇ(1)\) and \(ùëÇ(\log t_i)\) number of gates are added (each of which can be added in \(ùëÇ(1)\) time) respectively. Therefore, the total number of gates that would need to be added throughout the entire procedure would be atmost:<br><br>

$$ùëá(ùëî, ùê∂) ‚â§ ùëÇ(|ùê∂|)(\text{deg}(ùëî) + ùëÇ(1)) \text{deg}(ùëî) + \max\limits_i ùëÇ(\log t_i)$$

$$ùëá(ùëî, ùê∂) ‚â§ ùëÇ(|ùê∂|)\text{deg}(ùëî) + ùëÇ(|ùê∂|) + \max\limits_i ùëÇ(\log t_i) = \text{poly}(|C|, g) ùëñ$$

Therefore, the runtime of this procedure is in the size of \(C\), and takes space atmost \(g\). Hence, we now have a procedure that produces a circuit \(C'\) given \(C\) such that:

$$|{ùë¶: ùê∂'(ùë¶) = 1}| = ùëî(|{ùë•: ùê∂(ùë•) = 1}|)$$

QED.


<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 7: Constructing an efficiently computable non-negative polynomial \(g(t)\) for which \(t\equiv k\mod 2 \Rightarrow g(t) \equiv k \mod 2^m\), where \(m\) is a power of 2.</strong></button>
  <div class="content">
<br>

The purpose of this lemma is to create a deterministic procedure that, given \(m\) a power of two, outputs (as a sequence of coefficients) a polynomial \(ùíà: \mathbb{Z} ‚Üí \mathbb{Z}\) with nonnegative integer coefficients for which
$$t \equiv 0 \mod 2 \Rightarrow g(t) \equiv 0 \mod 2^m$$
$$t \equiv 1 \mod 2 \Rightarrow g(t) \equiv 1 \mod 2^m$$
and that runs in time \(poly(m)\).<br><br>

<u>Sub-Lemma 7.1</u>: \(t\equiv 0\mod 2^{2^i} \Rightarrow g_0(t) \equiv 0 \mod 2^{2^{i+1}}\), where \(g_0(t)=3t^2 - 2t^3\):<br><br>

Given that \(ùëî_0(t) = 3t^2 ‚àí 2t^3 = t^2(3 ‚àí 2t)\) and that \(t \equiv 0 \mod 2^{2^i}\), we let \(t = k\cdot 2^{2^i}, k \in \mathbb{N}\). It follows then that:
$$g_0(t) = t^2(3 ‚àí 2t) = ùëò^2 (2^{2^i})^2 (3‚àí2(ùëò\cdot 2^{2^ùëñ}))$$
$$= 3k^2 \cdot 2^{2^{ùëñ+1}} ‚àí 2k^3 \cdot 2^{2√ó2^{i+1}}$$
$$=3k^2 \cdot 2^{2^{ùëñ+1}} ‚àí8k^3 \cdot 2^{2^{i+1}}$$
$$= (\alpha + \beta) \cdot 2^{2^{i+!}}$$
$$= \gamma \cdot 2^{2^{i+1}}$$

Then, since \(ùõº ‚àà \mathbb{N}, ùõΩ ‚àà \mathbb{N}\), it follows that \(\gamma ‚àà \mathbb{N}\). Therefore,
$$\gamma \cdot 2^{2^{i+1}} \equiv 0 \mod 2^{2^{i+1}}$$
QED.<br>
<br>
<br>


<u>Sub-Lemma 7.2</u>: \(t\equiv 1 \mod 2^{2^i} \Rightarrow g_0(t) \equiv 1 \mod 2^{2^{i+1}}\), where \(g_0(t) = 3t^2 - 2t^3\):<br><br>

Given that \(g_0(t) = 3t^2 ‚àí 2t^3 = t^2(3 ‚àí 2t)\) and that \(t \equiv 1 \mod 2^{2^i}\), we let \(t=k\cdot 2^{2^i}+1\), for \(k \in \mathbb{N}\). It follows then that

$$g_0(t) = t^2(3 ‚àí 2t)$$

$$=(1+k^2\cdot 2^{2^{ùëñ+1}} + k\cdot 2^{2^{i+1}})(3 - 2 - k\cdot 2^{1+2^i})$$

$$ = 1 + 2^{2^{1+i}}k^2 ‚àí 2^{2+2^{1+i}}k^2 ‚àí 2^{1+2^i+2^{1+i}}k^3$$

$$= 1 + 2^{2^{1+i}}(‚àí3ùëò^2) ‚àí (1 + 2^i)k^3 2^{2^{1+i}}$$

$$= 1 + 2^{1+2^i}(-(2^i+1)k^3 - 3k^2)$$

Then, since \(ùëò, ùëñ ‚àà \mathbb{N}\), it follows that:

$$g_0(t)=1+2^{1+2^ùëñ}ùõΩ,\quad ùõΩ‚àà\mathbb{N}$$

Hence,
$$ùëî_0(t)=1+\beta\cdot 2^{2^{i+1}} \equiv 1 \mod 2^{2^{i+1}}$$

QED.<br><br><br>


Our goal is now to construct a deterministic procedure that outputs the coefficients of a polynomial \(ùëî: \mathbb{Z} ‚Üí \mathbb{Z}\) with nonnegative integer coefficients for which:

$$ùë° \equiv 0 \mod 2 \Rightarrow ùëî(ùë°) \equiv 0 \mod 2^ùëö$$

$$ùë° \equiv 1 \mod 2 \Rightarrow ùëî(ùë°) \equiv 1 \mod 2^ùëö$$

and that runs in \(ùëùùëúùëôùë¶(ùëö)\) where \(m\) is a power of \(2\). Therefore, let \(ùëö = 2^ùëò\), for \(ùëò ‚àà \mathbb{N}\). It follows then that we want to construct a procedure that outputs the coefficients to a polynomial \(g: \mathbb{Z} \rightarrow \mathbb{Z}\) such that

$$ùë° \equiv 0 \mod 2 \Rightarrow ùëî(ùë°) ‚â° 0 \mod 2^{2^ùëò}$$

$$t ‚â° 1 \mod 2 \Rightarrow ùëî(ùë°) ‚â° 1 \mod 2^{2^k}$$

To do so, we recall lemmas 7.1 and 7.2 with \(ùëî_0(t) = 3t^2 ‚àí 2t^3\) in that every application of \(ùëî_0\) causes the exponent of the exponent of the mod to increment by 1. Therefore, we claim that the coefficients of \(ùëî_0 ‚àò ùëî_0 ‚àò ... ‚àò ùëî_0(ùë°) = ùëî(ùë°)\) where \(k\) compositions are done.<br><br>

To prove this, we use mathematical induction on \(k\):<br><br>

<u>Base Case</u>: \(ùëò = 1, ùëö = 0\)<br>

No compositions would be done, so we would require \(ùëî(ùë°) = ùë°\). However, when

$$ùë°\equiv 0 \mod 2, g(t) \equiv 0 \mod 2^{2^0} \equiv 0\mod 2 = t$$

$$ùë°\equiv 1 \mod 2, g(t) \equiv 1 \mod 2^{2^0} \equiv 1\mod 2 = t$$

Hence the base case is satisfied.<br><br>

<u>Assumptive case</u>: We assume that \(g(ùë°) = ùëî_0 ‚àò ... ‚àò ùëî_0 (ùë°)\) for \(ùëò ‚â§ ùëõ\) compositions is true.<br><br>

<u>Inductive case</u>: When \(ùëò = ùëõ + 1\), we have that from the \((ùëò ‚àí 1)\)th composition (by the assumptive step), we would have:

$$t\equiv 0 \mod 2 \Rightarrow ùëî'(t) \equiv 0 \mod 2^{2^{k-1}}$$

$$t\equiv 1 \mod 2 \Rightarrow ùëî'(t) \equiv 1 \mod 2^{2^{k-1}}$$

Therefore, when we perform the \(k\)‚Äôth composition, we would then get:

$$ùë°\equiv 0 \mod 2 \Rightarrow ùëî(ùë°) \equiv 0\mod 2^{2^k}$$

$$ùë°\equiv 1 \mod 2 \Rightarrow ùëî(ùë°) \equiv 1\mod 2^{2^k}$$

Therefore, by the inductive hypothesis from the base case, we now have that \(ùëî_0 ‚àò ùëî_0 ‚àò ... ‚àò ùëî_0 (ùë°) = ùëî(ùë°)\) where \(k\) compositions are done. As desired.<br><br>


Finally, the onus of this proof is to show that this procedure runs in polynomial time in \(m\):<br><br>

<div class="single_indent">To do this, we note that each step of the composition involves atleast \(k\) evaluations through multiplication.</div>

<div class="single_indent">Therefore, the total number of multiplications would across all the steps would be \(O(2^k) = O(m)\). </div>
<div class="single_indent">Each multiplication runs in \(ùëùùëúùëôùë¶(ùëÇ(ùëò)) ‚àà ùëùùëúùëôùë¶(ùëö)\) time. </div>
<div class="single_indent">The total time complexity of this procedure is \(ùëùùëúùëôùë¶(ùëö) √ó ùëÇ(ùëö) = ùëùùëúùëôùë¶(ùëö)\).</div><br>

QED.


<br><br>
</div><br>


<button class="collapsible"><strong>Lemma 8: Concluding that \(\text{PH} \subseteq \text{P}^{\# \text{P}}\)</strong></button>
  <div class="content">
<br>
Recall Lemmas \(1\) and \(2\) which state that
$$\text{PH} ‚äÜ \text{BPP}^{\oplus \text{P}} $$
$$(\oplus \text{P})^{\oplus \text{P}} ‚äÜ \oplus \text{P} $$

<u>Lemma 8.1</u>: any language in \(\text{BPP}^{\oplus \text{P}}\) can be decided in \(BPP^{\oplus \text{P}}\) with the oracle machine making a single query and then immediately entering \(q_\text{accept}\) or \(q_\text{reject}\).<br><br>

Let \(ùêø ‚àà \text{BPP}^{\oplus \text{P}}\). Let \(M\) be a probabilistic \(TM\) with oracle \(\text{P}^{\oplus \text{P}}\) that decides a string \(x\) through the following procedure (and only tossing the coins redundantly):<br><br>

\(M(x)\):<br>
<div class="single_indent">Toss the \(c = |ùë•|\) coins and write down the results (what is actually done with the results is not relevant right now).</div><br>

<div class="single_indent">Query the oracle \(\text{P}^{\oplus \text{P}}\) on \(x\).</div><br>

<div class="single_indent">If the oracle returns ACCEPT, then enter \(ùëû_\text{ùëéùëêùëêùëíùëùùë°}\). If the oracle returns REJECT, then enter \(ùëû_\text{ùëüùëíùëóùëíùëêùë°}\).</div><br>

Therefore, we have that \(M\) decides \(L\) in \(\text{BPP}^{\text{P}^{\oplus \text{P}}}\). Recall Lemma 2 which states that \((\oplus \text{P})^{\oplus \text{P}} ‚äÜ \oplus \text{P}\). Since \(\text{P} ‚àà \oplus \text{P}\), we have that \(\text{P}^{\oplus \text{P}} ‚äÜ \oplus \text{P}\). Therefore, \(M\) decides \(L\) in \(\text{BPP}^{\oplus \text{P}}\).<br><br>

QED.


<br><br><br>
<u>Lemma 8.2</u>: The outcome of the query is determined by the number of satisfying assignments of some circuit \(C\).<br><br>

For the query made by \(M\) to \(\oplus \text{P}\), we let the turing machine that decides \(\oplus \text{P}\) be denoted as \(M'\). It follows then that \(M'\) has an equivalent circuit \(C\). It follows immediately that the outcome of the query (of form \(q: \{0, 1\}^c \rightarrow \{0, 1\}\) (where \(c\) is the number of coins)) depends on \(C\).<br><br>

To determine the relationship further, we recall that \(\oplus \text{P}\) returns ACCEPT if the number of computation paths is odd and REJECT if it is even. Therefore, for an oracle query \(q\) to return ACCEPT, the number of satisfying assignments for \(C\) would have to be odd (\(\equiv 1 \mod 2)\), and for it to return REJECT, the number of satisfying assignments for \(C\) would have to be even \((\equiv 0 \mod 2)\).<br><br>

Hence, we conclude that the outcome of the query is determined by the number of satisfying assignments of some circuit \(C\).<br><br>

QED.<br><br><br>


We now use Lemma \(7\) to produce a polynomial \(ùëî: \mathbb{N} ‚Üí \mathbb{N}\) such that \(ùë° \equiv 0 \mod 2 \Rightarrow g(t) \equiv 0 \mod 2^m\) and \(ùë° \equiv 1 \mod 2 \Rightarrow g(t) \equiv 1 \mod 2^m\), where \(m = c\) (the number of coins used by the turing machine \(M\)).<br><br>

We then use part a (providing circuit \(C\) with \(s\) satisfying assignments as an input) to produce circuit \(C'\) with \(ùëî(ùë†)\) satisfying assignments). Therefore, \(C'\) would have<br>

$$0 \mod 2^c \text{ satisfying assignments if } ùê∂ \text{ had } 0 \mod 2 \text{ satisfying assignments}.$$

$$1 \mod 2^c \text{ satisfying assignments if } ùê∂ \text{ had } 1 \mod 2 \text{ satisfying assignments}.$$

The onus of the proof is to now show that the language can be decided by a deterministic polynomial-time
turing machine \(Q\) that uses nondeterministic polynomial-time turing machine oracle \(Q'\) that runs in \(\#ùëÉ\).<br><br>

From lemma \(8.1\), we have that since the language \(L\) is decided by \(\text{BPP}\), atleast \(\frac{2}{3}\) of the computation paths correctly produce circuit \(C'\) when \(ùë• ‚àà ùêø\) such that \(C'\) has \(1 \mod 2^c\) satisfying assignments. Similarly, atmost \(\frac{1}{3}\) of the computation paths correctly produce circuit \(C'\) when \(ùë• ‚àâ ùêø\) such that \(C'\) has \(0 \mod 2^c\) satisfying assignments. Therefore, the total number of paths that produce \(C'\) with \(1 \mod 2^c\) satisfying assignments when \(ùë• ‚àà ùêø\) is \(‚â• \frac{2}{3}\cdot 2^c\), whereas the total number of paths that produce \(C'\) with \(0 \mod 2^c\) satisfying assignments when \(ùë• ‚àâ ùêø\) is \(‚â§ \frac{1}{3} \cdot 2^c\).<br><br>

Note then that we can use a \(\#ùëÉ\) oracle to find the total length of the set \(ùëÜ = (ùë• = \{0,1\}^ùëê) √ó ùëñ\) such that
\(ùê∂'(ùëû(ùë•), i) = 1\) where \(ùë•\) is every possible input of length \(c\) in the set, \(ùëû(ùë•)\) is a result of querying \(x\), and \(i\) is the \(d\)-dimensional input to \(C'\).<br><br>

Then, a polynomial procedure \(H\) does the following:<br><br>

<div class="single_indent">Use the method described in the previous paragraph to query an oracle to find the length of the set, |ùëÜ|.</div>
<div class="single_indent">Calculate \(ùëò = |ùëÜ| \mod 2^c\).</div><br>

<div class="single_indent">If \(ùëò ‚â• \frac{2}{3} \cdot 2^c\), then return ACCEPT.</div><br>

<div class="single_indent">If \(ùëò ‚â§ \frac{2}{3} \cdot 2^c\), then return REJECT.</div><br>

There are atleast \(\frac{2}{3}\) accepting paths that we explicitly search for and atmost \(\frac{1}{3}\) rejecting paths that we explicitly search for by using \(\#\text{P}\) which is then verified through the modulo operation by procedure \(H\). Hence, we now have that any for an arbitrary language \(ùêø ‚àà \text{BPP}^{\oplus \text{P}}\), \(ùêø ‚àà \text{P}^{\#\text{P}}\). Therefore, we now have that:<br>

$$\text{BPP}^{\oplus \text{P}} ‚äÜ \text{P}^{\#\text{P}}$$

However, recall result 1 from the previous set that:

$$\text{PH} ‚äÜ \text{BPP}^{\oplus \text{P}}$$

Therefore, by the property of transitivity we now have that

$$\text{PH} ‚äÜ \text{P}^{\#\text{P}}$$

QED.


<br><br><br>
</div><br>


    </div>
  </div>
</div>

<style>
.rectangle {
  height: 8%;
  width: 55%;
  background-color: black;
  margin-left: auto;
  margin-right: auto;
  color: white;
  display: flex;
  justify-content:center;
  align-items: center;
}


  .single_indent{
  text-indent: 50px;
}
.double_indent{
  text-indent: 100px;
}
.triple_indent{
  text-indent: 150px;
}

.quadruple_indent{
  text-indent: 200px;
}

.pentaple_indent{
  text-indent: 250px;
}

.hexaple_indent{
  text-indent: 300px;
}

    .centertitleph112 {
      display: block;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

</style>
</head>
<div class="footer">
    <a href="#" class="w3-button w3-white w3-padding-large w3-margin-bottom"><img src="../up_arrow.png", style="width: 25px;height:25px";></i>To the top</a><br>
    <a href=https://www.instagram.com/emiletimothy/><img src="Pictures/icons/instagram-icon.png", alt="Instagram", style="width:25px;height:25px";></a>
    <a href=https://www.linkedin.com/in/emiletimothy/><img src="Pictures/icons/linkedin-icon.png", alt="Linkedin", style="width:25px;height:25px";></a>
    <a href=https://orcid.org/my-orcid?orcid=0000-0003-2893-9469https://orcid.org/my-orcid?orcid=0000-0003-2893-9469/><img src="Pictures/icons/orcid-icon.png", alt="Orcid", style="width:25px;height:25px";></a>
    <a href=https://scholar.google.com/citations?user=nUXwVU8AAAAJ&hl=en/><img src="Pictures/icons/googlescholar-icon.png", alt="Google Scholar", style="width:25px;height:25px";></a>
    <a href=https://github.com/emiletimothy/><img src="../Pictures/icons/github-icon.png", alt="Github Icon", style="width:30px;height:29px";></a><br><br>
<p1 style="color: white"><br><strong>¬© 2023 by Emile Timothy</strong></p1>
</div>

</body>

</html>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("b1-active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    }
  });
}
</script>



<style>
/* Style the button that is used to open and close the collapsible content */
.collapsible {
  background-color: #000000;
  color: #ffffff;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  outline: 10px white;
  border: none;
  text-align: center;
  outline: none;
  font-size: 15px;
}

.collapsible:after {
  background-color: #000000;
  content: '+'; /* Unicode character for "plus" sign (+) */
  font-size: 13px;
  outline: #000000;
  color: #ffffff;
  float: right;
  margin-left: 5px;
}

.b1-active:after {
  color: #ffffff;
  font-size:10px;
  content: "-"; /* Unicode character for "minus" sign (-) */
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.b1-active, .collapsible:hover {
  background-color: #000000;
}

.content {
  padding: 0 18px;
  color: black;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}
</style>
